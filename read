fpga_load.h:1:/***********************  I n c l u d e  -  F i l e  ***********************/
fpga_load.h:16: *---------------------------------------------------------------------------
fpga_load.h:41:/*-----------------------------------------+
fpga_load.h:43:+-----------------------------------------*/
fpga_load.h:103:/*-----------------------------------------+
fpga_load.h:105:+-----------------------------------------*/
fpga_load.h:129:/*--- boot sector position --*/
fpga_load.h:140:/*----- A500 Bus switches --- */
fpga_load.h:150:#define LOG_TO_PHYS_ADDRREG(h) (h->pciDev.bar[h->bar] + h->addr_reg_offset)
fpga_load.h:151:#define LOG_TO_PHYS_DATAREG(h) (h->pciDev.bar[h->bar] + h->data_reg_offset)
fpga_load.h:154:#define MSECDIFF(basemsec)  (UOS_MsecTimerGet() - basemsec)
fpga_load.h:156:#define Z100_MREAD_D8 		h->Mread_D8
fpga_load.h:157:#define Z100_MREAD_D16 		h->Mread_D16
fpga_load.h:158:#define Z100_MREAD_D32		h->Mread_D32
fpga_load.h:159:#define Z100_MWRITE_D8 		h->Mwrite_D8
fpga_load.h:160:#define Z100_MWRITE_D16 	h->Mwrite_D16
fpga_load.h:161:#define Z100_MWRITE_D32 	h->Mwrite_D32
fpga_load.h:162:#define Z100_FLASH_WRITE	h->Write
fpga_load.h:163:#define Z100_FLASH_READ		h->Read
fpga_load.h:165:/*-----------------------------------------------------------------------
fpga_load.h:167: *----------------------------------------------------------------------*/
fpga_load.h:194:/*-----------------------------------------+
fpga_load.h:196:+-----------------------------------------*/
fpga_load.h:221:	long bar[6];			/**< BAR0 - BAR5 */
fpga_load.h:284:/*-----------------------------------------+
fpga_load.h:286:+-----------------------------------------*/
fpga_load.h:291:/*-----------------------------------------+
fpga_load.h:293:+-----------------------------------------*/
_st_sw_stub.c:1:/*********************  P r o g r a m  -  M o d u l e ***********************/
_st_sw_stub.c:12: *     Required: -
_st_sw_stub.c:15: /*---------------------------[ Public Functions ]----------------------------
_st_sw_stub.c:18: *---------------------------------------------------------------------------
flash_com.c:1:/*********************  P r o g r a m  -  M o d u l e ***********************/
flash_com.c:12: *     Required: -
flash_com.c:15:/*---------------------------[ Public Functions ]----------------------------
flash_com.c:19: *---------------------------------------------------------------------------
flash_com.c:20: * (c) Copyright 2004-2009 by MEN Mikro Elektronik GmbH, Nuremberg, Germany
flash_com.c:40:/*--------------------------------------+
flash_com.c:42:+--------------------------------------*/
flash_com.c:51:/*--------------------------------------+
flash_com.c:53:+--------------------------------------*/
flash_com.c:55:/*--------------------------------------+
flash_com.c:57:+--------------------------------------*/
flash_com.c:60:/*--------------------------------------+
flash_com.c:62:+--------------------------------------*/
flash_com.c:64:/*--------------------------------------+
flash_com.c:66:+--------------------------------------*/
flash_com.c:71: *---------------------------------------------------------------------------
flash_com.c:89:	DEV_HDL *h = fDev->devHdl;
flash_com.c:94:	if( fDev->devHdl->flash_acc_size )/* access 16 bit data bus */
flash_com.c:105:		/*--- read word by word or byte by byte, extracting valid bytes ---*/
flash_com.c:106:		retVal = Z100_FLASH_READ( fDev->devHdl, offset);
flash_com.c:108:				__FUNCTION__, __LINE__, nAccess, offset, retVal,fDev->devHdl->flash_acc_size);
flash_com.c:110:		if( fDev->devHdl->flash_acc_size )/* access 16 bit data bus */
flash_com.c:112:			if (fDev->devHdl->flashDev.devId == 0x227E){
flash_com.c:116:			nAccess--;
flash_com.c:120:			nAccess--;
_istrata_mmod_stub.c:1:/*********************  P r o g r a m  -  M o d u l e ***********************/
_istrata_mmod_stub.c:9: *        \brief  instance for IntelStrata Flash m-module version
_istrata_mmod_stub.c:12: *     Required: -
_istrata_mmod_stub.c:15: /*---------------------------[ Public Functions ]----------------------------
_istrata_mmod_stub.c:18: *---------------------------------------------------------------------------
_istrata_stub.c:1:/*********************  P r o g r a m  -  M o d u l e ***********************/
_istrata_stub.c:12: *     Required: -
_istrata_stub.c:15: /*---------------------------[ Public Functions ]----------------------------
_istrata_stub.c:18: *---------------------------------------------------------------------------
_istrata_mmod_sw_stub.c:1:/*********************  P r o g r a m  -  M o d u l e ***********************/
_istrata_mmod_sw_stub.c:9: *        \brief  instance for IntelStrata Flash swapped m-module version
_istrata_mmod_sw_stub.c:12: *     Required: -
_istrata_mmod_sw_stub.c:15: /*---------------------------[ Public Functions ]----------------------------
_istrata_mmod_sw_stub.c:18: *---------------------------------------------------------------------------
hw_acc_mmod.c:7: *        $Date: 2019-01-16 $
hw_acc_mmod.c:13: *    \switches FL_SWAP_SW       - for swapped Version\n
hw_acc_mmod.c:17: *----------------------------------------------------------------------------
hw_acc_mmod.c:34:/*-----------------------------------------+
hw_acc_mmod.c:36: +-----------------------------------------*/
hw_acc_mmod.c:38:/*-----------------------------------------+
hw_acc_mmod.c:40: +-----------------------------------------*/
hw_acc_mmod.c:58:/*-----------------------------------------+
hw_acc_mmod.c:60: +-----------------------------------------*/
hw_acc_mmod.c:63:/*-----------------------------------------+
hw_acc_mmod.c:65: +-----------------------------------------*/
hw_acc_mmod.c:151:   if( !h->smbLocHdl.smbHdl )
hw_acc_mmod.c:153:      Z100_MWRITE_D32( h->mappedAddr,
hw_acc_mmod.c:156:      if(h->flash_acc_size) /* access 16 bit data bus */
hw_acc_mmod.c:157:         Z100_MWRITE_D16( h->mappedAddr,
hw_acc_mmod.c:161:         Z100_MWRITE_D8( h->mappedAddr,
hw_acc_mmod.c:165:            (unsigned int)h->mappedAddr, (unsigned int)offs, (unsigned int)val); */
hw_acc_mmod.c:175:   if( !h->smbLocHdl.smbHdl )
hw_acc_mmod.c:177:      Z100_MWRITE_D32( h->mappedAddr,
hw_acc_mmod.c:180:      if(h->flash_acc_size) /* access 16 bit data bus */
hw_acc_mmod.c:181:         retVal = Z100_MREAD_D16( h->mappedAddr,
hw_acc_mmod.c:184:         retVal = Z100_MREAD_D8( h->mappedAddr,
hw_acc_mmod.c:187:             (unsigned int)h->mappedAddr, (unsigned int)offs, (unsigned int)retVal); */
hw_acc_mmod.c:191:      retVal = -1;
hw_acc_io.c:17: *------------------------------------------------------------------------------
program.mak:9:#---------------------------------[ History ]---------------------------------
program.mak:33:#   R : Do not call the right men-oss library to build statically
program.mak:34:#   M : change the path and the library called from men_oss to ../men-oss
program.mak:55:#     - SMB support by default
program.mak:56:#     - smb2_all_usr lib (use SMB21 lib with MAC_USER_SPACE switch set)
program.mak:60:#   added: stubs for swapped and non-swapped versions
program.mak:86:#-----------------------------------------------------------------------------
program.mak:137:#	MAK_LIBS +=	$(LIB_PREFIX)$(MEN_LIB_DIR)/../men-oss$(DBGSUFFIX)$(LIB_SUFFIX)
program.mak:139:#		MAK_LIBS +=	$(LIB_PREFIX)$(MEN_LIB_DIR)/../men-libc$(LIB_SUFFIX)
hw_acc.c:13: *    \switches FL_SWAP_SW       - for swapped Version\n
hw_acc.c:14: *              FL_SWAP_MMOD_SW  - for swapped M-Module\n
hw_acc.c:15: *              FL_SWAP_MMOD     - for M-Module\n
hw_acc.c:19: *----------------------------------------------------------------------------
hw_acc.c:36:/*-----------------------------------------+
hw_acc.c:38: +-----------------------------------------*/
hw_acc.c:40:/*-----------------------------------------+
hw_acc.c:42: +-----------------------------------------*/
hw_acc.c:54:/*-----------------------------------------+
hw_acc.c:56: +-----------------------------------------*/
hw_acc.c:57:/*-----------------------------------------+
hw_acc.c:59: +-----------------------------------------*/
hw_acc.c:149:	if( !h->smbLocHdl.smbHdl )
hw_acc.c:151:		Z100_MWRITE_D32( h->mappedAddr,
hw_acc.c:154:		if(h->flash_acc_size) /* access 16 bit data bus */
hw_acc.c:155:			Z100_MWRITE_D16( h->mappedAddr,
hw_acc.c:159:			Z100_MWRITE_D8( h->mappedAddr,
hw_acc.c:163:				(unsigned int)h->mappedAddr, (unsigned int)offs, (unsigned int)val); */
hw_acc.c:172:	if( !h->smbLocHdl.smbHdl )
hw_acc.c:174:		Z100_MWRITE_D32( h->mappedAddr,
hw_acc.c:177:		if(h->flash_acc_size) /* access 16 bit data bus */
hw_acc.c:178:			retVal = Z100_MREAD_D16( h->mappedAddr,
hw_acc.c:181:			retVal = Z100_MREAD_D8( h->mappedAddr,
hw_acc.c:184:				 (unsigned int)h->mappedAddr, (unsigned int)offs, (unsigned int)retVal); */
hw_acc.c:188:		retVal = -1;
istratapc28fxxxp30.c:1:/*********************  P r o g r a m  -  M o d u l e ***********************/
istratapc28fxxxp30.c:12: *     Required: -
istratapc28fxxxp30.c:15: /*---------------------------[ Public Functions ]----------------------------
istratapc28fxxxp30.c:19: *---------------------------------------------------------------------------
istratapc28fxxxp30.c:40:/*--------------------------------------+
istratapc28fxxxp30.c:42:+--------------------------------------*/
istratapc28fxxxp30.c:52:/*--- command codes for INTEL ---*/
istratapc28fxxxp30.c:67:#define C_LOCKDOWNBLOCK		0xF2	/* Lock-Down Block second cycle */
istratapc28fxxxp30.c:77:/*--- known manufacturer codes/device codes ---*/
istratapc28fxxxp30.c:87:/*--------------------------------------+
istratapc28fxxxp30.c:89:+--------------------------------------*/
istratapc28fxxxp30.c:92:/*--------------------------------------+
istratapc28fxxxp30.c:94:+--------------------------------------*/
istratapc28fxxxp30.c:97:/*--------------------------------------+
istratapc28fxxxp30.c:99:+--------------------------------------*/
istratapc28fxxxp30.c:124:/*--------------------------------------+
istratapc28fxxxp30.c:126:+--------------------------------------*/
istratapc28fxxxp30.c:181: *-----------------------------------------------------------------------------
istratapc28fxxxp30.c:197:	if(devHdl->mapType){
istratapc28fxxxp30.c:200:			devHdl->Mread_D8   = Z100_Mread_Io_D8_Sw;
istratapc28fxxxp30.c:201:			devHdl->Mread_D16  = Z100_Mread_Io_D16_Sw;
istratapc28fxxxp30.c:202:			devHdl->Mread_D32  = Z100_Mread_Io_D32_Sw;
istratapc28fxxxp30.c:203:			devHdl->Mwrite_D8  = Z100_Mwrite_Io_D8_Sw;
istratapc28fxxxp30.c:204:			devHdl->Mwrite_D16 = Z100_Mwrite_Io_D16_Sw;
istratapc28fxxxp30.c:205:			devHdl->Mwrite_D32 = Z100_Mwrite_Io_D32_Sw;
istratapc28fxxxp30.c:207:			devHdl->Mread_D8   = Z100_Mread_Io_D8;
istratapc28fxxxp30.c:208:			devHdl->Mread_D16  = Z100_Mread_Io_D16;
istratapc28fxxxp30.c:209:			devHdl->Mread_D32  = Z100_Mread_Io_D32;
istratapc28fxxxp30.c:210:			devHdl->Mwrite_D8  = Z100_Mwrite_Io_D8;
istratapc28fxxxp30.c:211:			devHdl->Mwrite_D16 = Z100_Mwrite_Io_D16;
istratapc28fxxxp30.c:212:			devHdl->Mwrite_D32 = Z100_Mwrite_Io_D32;
istratapc28fxxxp30.c:220:	/*--- get read / write function pointer ---*/
istratapc28fxxxp30.c:221:	devHdl->Mread_D8   = Z100_Mread_Mem_D8;
istratapc28fxxxp30.c:222:	devHdl->Mread_D16  = Z100_Mread_Mem_D16;
istratapc28fxxxp30.c:223:	devHdl->Mread_D32  = Z100_Mread_Mem_D32;
istratapc28fxxxp30.c:224:	devHdl->Mwrite_D8  = Z100_Mwrite_Mem_D8;
istratapc28fxxxp30.c:225:	devHdl->Mwrite_D16 = Z100_Mwrite_Mem_D16;
istratapc28fxxxp30.c:226:	devHdl->Mwrite_D32 = Z100_Mwrite_Mem_D32;
istratapc28fxxxp30.c:231:	devHdl->Read  = Z100_Flash_Read;
istratapc28fxxxp30.c:232:	devHdl->Write = Z100_Flash_Write;
istratapc28fxxxp30.c:243:			(int)devHdl->flashDev.manId, (int)devHdl->flashDev.devId,
istratapc28fxxxp30.c:244:			(int)devHdl->flashDev.sectSize, (int)devHdl->flashDev.nSectors,
istratapc28fxxxp30.c:245:			(int)devHdl->flashDev.bootSect));
istratapc28fxxxp30.c:260:/*----------------------------------------------------------------------
istratapc28fxxxp30.c:262: *---------------------------------------------------------------------*/
istratapc28fxxxp30.c:269: *-----------------------------------------------------------------------------
istratapc28fxxxp30.c:276:	FLASH_ENTRY *ent = &h->flash_entry;
istratapc28fxxxp30.c:278:	ent->Exit 			= &Exit;
istratapc28fxxxp30.c:279:	ent->Reset 			= &Reset;
istratapc28fxxxp30.c:280:	ent->ReadBlock 		= &ReadBlock;
istratapc28fxxxp30.c:281:	ent->WriteBlock		= &WriteBlock;
istratapc28fxxxp30.c:282:	ent->EraseChip  	= &EraseChip;
istratapc28fxxxp30.c:283:	ent->EraseSectors	= &EraseSectors;
istratapc28fxxxp30.c:284:	h->flashDev.isInit	= TRUE;
istratapc28fxxxp30.c:286:	Reset(&h->flashDev);		/* reset device to read mode */
istratapc28fxxxp30.c:294: *-----------------------------------------------------------------------------
istratapc28fxxxp30.c:304:	fDev->devHdl->flashDev.isInit = FALSE;
istratapc28fxxxp30.c:313: *-----------------------------------------------------------------------------
istratapc28fxxxp30.c:326:	devHdl->flash_acc_size = Z100_FLASH_ACCESS_16BIT;		/* 16 bit Flash */
istratapc28fxxxp30.c:328:	/*--- write devId command ---*/
istratapc28fxxxp30.c:334:		devHdl->flashDev.manId = retval & 0xffff;
istratapc28fxxxp30.c:336:		/*--- read devId ---*/
istratapc28fxxxp30.c:339:		while (devs->devId){
istratapc28fxxxp30.c:341:			/*--- check if devId equal to one of IntelDevIds ---*/
istratapc28fxxxp30.c:342:			if((u_int32)devs->devId ==  retval)
istratapc28fxxxp30.c:344:				devHdl->flashDev.devId = retval;
istratapc28fxxxp30.c:351:	if( devHdl->dbgLevel )
istratapc28fxxxp30.c:353:				(unsigned int)devHdl->flashDev.manId,
istratapc28fxxxp30.c:354:				(int)devHdl->flashDev.devId);
istratapc28fxxxp30.c:361: * ---------------------------------------------------------------------------
istratapc28fxxxp30.c:364: *  Globals....: -
istratapc28fxxxp30.c:369:			(unsigned int)devHdl->flashDev.manId,
istratapc28fxxxp30.c:370:			(int)devHdl->flashDev.devId) );
istratapc28fxxxp30.c:372:	/*--- check if device is supported ---*/
istratapc28fxxxp30.c:373:	if( devHdl->flashDev.manId == MANUFACT_INTEL )
istratapc28fxxxp30.c:378:		while( d->devId ){
istratapc28fxxxp30.c:379:			if( ( devHdl->flashDev.devId == d->devId ) &&
istratapc28fxxxp30.c:380:			 	( devHdl->flashDev.manId == d->manId) )
istratapc28fxxxp30.c:382:				if(devHdl->dbgLevel)
istratapc28fxxxp30.c:384:						 "    Found FLASH device %s\n", d->name );
istratapc28fxxxp30.c:386:				devHdl->flashDev.sectSize = d->sectSize;
istratapc28fxxxp30.c:387:				devHdl->flashDev.nSectors = d->nSectors;
istratapc28fxxxp30.c:388:				devHdl->flashDev.bootSect = d->bootSect;
istratapc28fxxxp30.c:390:					devHdl->flashDev.sectAddr[i] = d->sectAddr[i];
istratapc28fxxxp30.c:391:				devHdl->flashDev.devHdl   = devHdl;
istratapc28fxxxp30.c:392:				devHdl->flashDev.isInit  = 0;
istratapc28fxxxp30.c:405: *-----------------------------------------------------------------------------
istratapc28fxxxp30.c:427: *---------------------------------------------------------------------------
istratapc28fxxxp30.c:438:	DEV_HDL *h = fDev->devHdl;
istratapc28fxxxp30.c:442:	/*--- check start address ---*/
istratapc28fxxxp30.c:443:	if(startOffs >= fDev->sectAddr[fDev->nSectors]*2){
istratapc28fxxxp30.c:448:	/*--- limit to device size ---*/
istratapc28fxxxp30.c:449:	if( (startOffs + len) >= fDev->sectAddr[fDev->nSectors]*2 )
istratapc28fxxxp30.c:450:		len = fDev->sectAddr[fDev->nSectors]*2 - startOffs - 1;
istratapc28fxxxp30.c:453:	phyEnd   = startOffs + len -1;
istratapc28fxxxp30.c:455:	/*--- convert to sector boundaries ---*/
istratapc28fxxxp30.c:457:	phyStart &= ~(sectSize-1);
istratapc28fxxxp30.c:460:	phyEnd &= ~(sectSize-1);
istratapc28fxxxp30.c:471:		if( fDev->devHdl->dbgLevel )
istratapc28fxxxp30.c:473:					(int)sect+1, (int)fDev->nSectors, (unsigned int)sectSize);
istratapc28fxxxp30.c:475:		/*--- clear status register ---*/
istratapc28fxxxp30.c:476:		Z100_FLASH_WRITE( fDev->devHdl, phyStart, C_CLEARSTATREG);
istratapc28fxxxp30.c:478:		/*--- unlock blocked sector ---*/
istratapc28fxxxp30.c:481:		/*--- give CHIP ERASE commands ---*/
istratapc28fxxxp30.c:482:		Z100_FLASH_WRITE( fDev->devHdl, phyStart, C_BLOCKERASE1);
istratapc28fxxxp30.c:483:		Z100_FLASH_WRITE( fDev->devHdl, phyStart, C_BLOCKERASE2);
istratapc28fxxxp30.c:485:		error = DataPollingAlg(fDev->devHdl, phyStart, 0xFF, 10000);
istratapc28fxxxp30.c:489:		if( fDev->devHdl->dbgLevel )
istratapc28fxxxp30.c:490:			printf("    Erase Sector ----> OK\n");
istratapc28fxxxp30.c:505: *-----------------------------------------------------------------------------
istratapc28fxxxp30.c:523:	DEV_HDL *h = fDev->devHdl;
istratapc28fxxxp30.c:529:    if( ( offs >= fDev->sectAddr[fDev->nSectors]*2) ||
istratapc28fxxxp30.c:530:        ((offs + len) > fDev->sectAddr[fDev->nSectors]*2))
istratapc28fxxxp30.c:542:		/*--- clear status register ---*/
istratapc28fxxxp30.c:545:		/*--- issue command cycles ---*/
istratapc28fxxxp30.c:554:		nWrite--;
istratapc28fxxxp30.c:570: *-----------------------------------------------------------------------------
istratapc28fxxxp30.c:588:	DEV_HDL *h = fDev->devHdl;
istratapc28fxxxp30.c:599:		retVal = Z100_FLASH_READ( fDev->devHdl, offset);
istratapc28fxxxp30.c:602:		nAccess--;
istratapc28fxxxp30.c:612: *---------------------------------------------------------------------------
istratapc28fxxxp30.c:617:	DEV_HDL *h = fDev->devHdl;
istratapc28fxxxp30.c:618:	Z100_FLASH_WRITE( fDev->devHdl, 0x00, C_READARRAY);
istratapc28fxxxp30.c:625: *-----------------------------------------------------------------------------
istratapc28fxxxp30.c:651:		/*--- check state SR7 ---*/
istratapc28fxxxp30.c:652:		if ( retVal & 0x80 ){	/*--- WSM ready ---*/
istratapc28fxxxp30.c:661:			/*--- clear status register ---*/
istratapc28fxxxp30.c:663:			/*--- set read array mode ---*/
istratapc28fxxxp30.c:683: *-----------------------------------------------------------------------------
istratapc28fxxxp30.c:688: *  \return	sector number or error (-1) if not found
istratapc28fxxxp30.c:694:	addr &= (fDev->sectAddr[fDev->nSectors]*2 - 1);
istratapc28fxxxp30.c:697:	for( sect=0; sect < fDev->nSectors; sect++ ){
istratapc28fxxxp30.c:698:		if( addr >= fDev->sectAddr[sect]*2 &&
istratapc28fxxxp30.c:699:			addr < fDev->sectAddr[sect+1]*2){
istratapc28fxxxp30.c:700:			*phySizeP = (fDev->sectAddr[sect+1] - fDev->sectAddr[sect])*2;
istratapc28fxxxp30.c:705:	return -1;
istratapc28fxxxp30.c:712: *-----------------------------------------------------------------------------
istratapc28fxxxp30.c:721:	DEV_HDL *h = fDev->devHdl;
istratapc28fxxxp30.c:724:	if( fDev->devHdl->dbgLevel )
istratapc28fxxxp30.c:727:	/*--- give UNLOCK BLOCK command ---*/
istratapc28fxxxp30.c:728:	if ( fDev->manId == MANUFACT_INTEL ) {
istratapc28fxxxp30.c:729:		Z100_FLASH_WRITE( fDev->devHdl, startOffs, C_LOCKUNLOCK  );
istratapc28fxxxp30.c:730:		Z100_FLASH_WRITE( fDev->devHdl, startOffs, C_UNLOCKBLOCK );
istratapc28fxxxp30.c:732:	error = DataPollingAlg(fDev->devHdl, startOffs, 0xFF, 10000);
istratapc28fxxxp30.c:733:	if ((!error) && ( fDev->devHdl->dbgLevel ))
istratapc28fxxxp30.c:734:		printf("    Unlock Block ----> OK\n");
_amd_stub.c:1:/*********************  P r o g r a m  -  M o d u l e ***********************/
_amd_stub.c:12: *     Required: -
_amd_stub.c:15: /*---------------------------[ Public Functions ]----------------------------
_amd_stub.c:18: *---------------------------------------------------------------------------
_istrata_sw_stub.c:1:/*********************  P r o g r a m  -  M o d u l e ***********************/
_istrata_sw_stub.c:12: *     Required: -
_istrata_sw_stub.c:15: /*---------------------------[ Public Functions ]----------------------------
_istrata_sw_stub.c:18: *---------------------------------------------------------------------------
am29lvxxx.c:1:/*********************  P r o g r a m  -  M o d u l e ***********************/
am29lvxxx.c:12: *     Required: -
am29lvxxx.c:15: /*---------------------------[ Public Functions ]----------------------------
am29lvxxx.c:19: *---------------------------------------------------------------------------
am29lvxxx.c:39:/*--------------------------------------+
am29lvxxx.c:41:+--------------------------------------*/
am29lvxxx.c:43:/*--- command codes ---*/
am29lvxxx.c:52:/*--- known manufacturer codes/device codes ---*/
am29lvxxx.c:75:/*--- erase states ---*/
am29lvxxx.c:89:/*--------------------------------------+
am29lvxxx.c:91:+--------------------------------------*/
am29lvxxx.c:93:/*--------------------------------------+
am29lvxxx.c:95:+--------------------------------------*/
am29lvxxx.c:98:/*--------------------------------------+
am29lvxxx.c:100:+--------------------------------------*/
am29lvxxx.c:256:/*--------------------------------------+
am29lvxxx.c:258:+--------------------------------------*/
am29lvxxx.c:294: *---------------------------------------------------------------------------
am29lvxxx.c:310:	if(devHdl->mapType){
am29lvxxx.c:313:			devHdl->Mread_D8   = Z100_Mread_Io_D8_Sw;
am29lvxxx.c:314:			devHdl->Mread_D16  = Z100_Mread_Io_D16_Sw;
am29lvxxx.c:315:			devHdl->Mread_D32  = Z100_Mread_Io_D32_Sw;
am29lvxxx.c:316:			devHdl->Mwrite_D8  = Z100_Mwrite_Io_D8_Sw;
am29lvxxx.c:317:			devHdl->Mwrite_D16 = Z100_Mwrite_Io_D16_Sw;
am29lvxxx.c:318:			devHdl->Mwrite_D32 = Z100_Mwrite_Io_D32_Sw;
am29lvxxx.c:320:			devHdl->Mread_D8   = Z100_Mread_Io_D8;
am29lvxxx.c:321:			devHdl->Mread_D16  = Z100_Mread_Io_D16;
am29lvxxx.c:322:			devHdl->Mread_D32  = Z100_Mread_Io_D32;
am29lvxxx.c:323:			devHdl->Mwrite_D8  = Z100_Mwrite_Io_D8;
am29lvxxx.c:324:			devHdl->Mwrite_D16 = Z100_Mwrite_Io_D16;
am29lvxxx.c:325:			devHdl->Mwrite_D32 = Z100_Mwrite_Io_D32;
am29lvxxx.c:333:	/*--- get read / write function pointer ---*/
am29lvxxx.c:334:	devHdl->Mread_D8   = Z100_Mread_Mem_D8;
am29lvxxx.c:335:	devHdl->Mread_D16  = Z100_Mread_Mem_D16;
am29lvxxx.c:336:	devHdl->Mread_D32  = Z100_Mread_Mem_D32;
am29lvxxx.c:337:	devHdl->Mwrite_D8  = Z100_Mwrite_Mem_D8;
am29lvxxx.c:338:	devHdl->Mwrite_D16 = Z100_Mwrite_Mem_D16;
am29lvxxx.c:339:	devHdl->Mwrite_D32 = Z100_Mwrite_Mem_D32;
am29lvxxx.c:344:	devHdl->Read  = Z100_Flash_Read;
am29lvxxx.c:345:	devHdl->Write = Z100_Flash_Write;
am29lvxxx.c:356:			(int)devHdl->flashDev.manId, (int)devHdl->flashDev.devId,
am29lvxxx.c:357:			(int)devHdl->flashDev.sectSize, (int)devHdl->flashDev.nSectors,
am29lvxxx.c:358:			(int)devHdl->flashDev.bootSect));
am29lvxxx.c:377: *---------------------------------------------------------------------------
am29lvxxx.c:384:	FLASH_ENTRY *ent = &h->flash_entry;
am29lvxxx.c:386:	ent->Exit 		= &Exit;
am29lvxxx.c:387:	ent->Reset 		= &Reset;
am29lvxxx.c:388:	ent->ReadBlock 	= &Z100_FLASH_READ_BLOCK;
am29lvxxx.c:389:	ent->WriteBlock	= &WriteBlock;
am29lvxxx.c:390:	ent->EraseChip  = &EraseChip;
am29lvxxx.c:391:	ent->EraseSectors= &EraseSectors;
am29lvxxx.c:392:	h->flashDev.isInit = TRUE;
am29lvxxx.c:394:	Reset(&h->flashDev);				/* reset device to read mode */
am29lvxxx.c:401: *---------------------------------------------------------------------------
am29lvxxx.c:411:	fDev->devHdl->flashDev.isInit = FALSE;
am29lvxxx.c:415:/*----------------------------------------------------------------------
am29lvxxx.c:417: *---------------------------------------------------------------------*/
am29lvxxx.c:423: *---------------------------------------------------------------------------
am29lvxxx.c:433:	addrreg = Z100_MREAD_D32( h->mappedAddr, Z045_FLASH_ADDR_REG_OFFSET);
am29lvxxx.c:437:		h->flash_acc_size = Z100_FLASH_ACCESS_16BIT;
am29lvxxx.c:440:		h->flash_acc_size = Z100_FLASH_ACCESS_8BIT;
am29lvxxx.c:444:	 (int)addrreg, h->flash_acc_size ? "16bit" : "8bit"));
am29lvxxx.c:451:	if( devHdl->flash_acc_size == Z100_FLASH_ACCESS_16BIT ) {
am29lvxxx.c:453:		devHdl->flashDev.manId = retval & 0xff;
am29lvxxx.c:455:		devHdl->flashDev.devId = retval & 0xffff;
am29lvxxx.c:458:		devHdl->flashDev.manId = retval & 0xff;
am29lvxxx.c:460:		devHdl->flashDev.devId = retval & 0xff;
am29lvxxx.c:463:    if ((devHdl->flashDev.manId != MANUFACT_ST)  &&
am29lvxxx.c:464:        (devHdl->flashDev.manId != MANUFACT_AMD) &&
am29lvxxx.c:465:        (devHdl->flashDev.manId != MANUFACT_MXIC))
am29lvxxx.c:468:        h->flash_acc_size = Z100_FLASH_ACCESS_8BIT;
am29lvxxx.c:473:        if( devHdl->flash_acc_size == Z100_FLASH_ACCESS_16BIT ) {
am29lvxxx.c:475:    		devHdl->flashDev.manId = retval & 0xff;
am29lvxxx.c:477:    		devHdl->flashDev.devId = retval & 0xffff;
am29lvxxx.c:480:			h->flash_acc_size = Z100_FLASH_ACCESS_16BIT;
am29lvxxx.c:482:    		devHdl->flashDev.manId = retval & 0xff;
am29lvxxx.c:484:    		devHdl->flashDev.devId = retval & 0xffff;
am29lvxxx.c:489:	if( devHdl->dbgLevel )
am29lvxxx.c:491:				(unsigned int)devHdl->flashDev.manId, (int)devHdl->flashDev.devId);
am29lvxxx.c:498: * ---------------------------------------------------------------------------
am29lvxxx.c:501: *  Globals....: -
am29lvxxx.c:506:			(unsigned int)devHdl->flashDev.manId,
am29lvxxx.c:507:			(int)devHdl->flashDev.devId) );
am29lvxxx.c:509:	/*--- check if device supported ---*/
am29lvxxx.c:510:	if( devHdl->flashDev.manId == MANUFACT_AMD ||
am29lvxxx.c:511:		devHdl->flashDev.manId == MANUFACT_ST ||
am29lvxxx.c:512:		devHdl->flashDev.manId == MANUFACT_MXIC )
am29lvxxx.c:517:		while( d->devId ){
am29lvxxx.c:518:			if( ( (devHdl->flash_acc_size == Z100_FLASH_ACCESS_16BIT &&
am29lvxxx.c:519:				   devHdl->flashDev.devId == d->devId) ||
am29lvxxx.c:520:			 	  (devHdl->flash_acc_size == Z100_FLASH_ACCESS_8BIT &&
am29lvxxx.c:521:			 	   devHdl->flashDev.devId == (d->devId & 0xff)) ) &&
am29lvxxx.c:522:			 	(devHdl->flashDev.manId == d->manId) )
am29lvxxx.c:524:				if(devHdl->dbgLevel)
am29lvxxx.c:526:						 "    Found FLASH device %s\n", d->name );
am29lvxxx.c:528:				devHdl->flashDev.sectSize = d->sectSize;
am29lvxxx.c:529:				devHdl->flashDev.nSectors = d->nSectors;
am29lvxxx.c:530:				devHdl->flashDev.bootSect = d->bootSect;
am29lvxxx.c:532:					devHdl->flashDev.sectAddr[i] = d->sectAddr[i];
am29lvxxx.c:533:				devHdl->flashDev.devHdl   = devHdl;
am29lvxxx.c:534:				devHdl->flashDev.isInit  = 0;
am29lvxxx.c:547: *---------------------------------------------------------------------------
am29lvxxx.c:555:	DEV_HDL *h = fDev->devHdl;
am29lvxxx.c:559:	if( fDev->devHdl->flash_acc_size ) { /* access 16 bit data bus */
am29lvxxx.c:564:	if (fDev->devHdl->flashDev.devId == DEVCODE_29GL064A){
am29lvxxx.c:568:	/*--- give CHIP ERASE command ---*/
am29lvxxx.c:569:	Command( fDev->devHdl, 5, C_ERASE1 );
am29lvxxx.c:570:	Z100_FLASH_WRITE( fDev->devHdl, offs, C_ERASE2_CHIP);
am29lvxxx.c:572:	error = DataPollingAlg(fDev->devHdl, 0, 0xFF, 50000);
am29lvxxx.c:584: *---------------------------------------------------------------------------
am29lvxxx.c:595:	DEV_HDL *h = fDev->devHdl;
am29lvxxx.c:601:	/*--- check start address ---*/
am29lvxxx.c:602:	if(startOffs >= fDev->sectAddr[fDev->nSectors]*2){
am29lvxxx.c:607:	/*--- limit to device size ---*/
am29lvxxx.c:608:	if( (startOffs + len) >= fDev->sectAddr[fDev->nSectors]*2 )
am29lvxxx.c:609:		len = fDev->sectAddr[fDev->nSectors]*2 - startOffs - 1;
am29lvxxx.c:612:	phyEnd   = startOffs + len -1;
am29lvxxx.c:614:	/*--- convert to sector boundaries ---*/
am29lvxxx.c:616:	phyStart &= ~(sectSize-1);
am29lvxxx.c:619:	phyEnd &= ~(sectSize-1);
am29lvxxx.c:630:		if( fDev->devHdl->dbgLevel )
am29lvxxx.c:632:					(int)sect+1, (int)fDev->nSectors, (unsigned int)sectSize);
am29lvxxx.c:633:		/*--- give CHIP ERASE command ---*/
am29lvxxx.c:634:		Command( fDev->devHdl, 5, C_ERASE1 );
am29lvxxx.c:635:		Z100_FLASH_WRITE( fDev->devHdl, phyStart, C_ERASE2_SECTOR);
am29lvxxx.c:637:		error = DataPollingAlg(fDev->devHdl, phyStart, 0xFF, 10000);
am29lvxxx.c:641:		if( fDev->devHdl->dbgLevel )
am29lvxxx.c:642:			printf("            ----> OK\n");
am29lvxxx.c:654: *---------------------------------------------------------------------------
am29lvxxx.c:673:	DEV_HDL *h = fDev->devHdl;
am29lvxxx.c:679:    if( ( offs >= fDev->sectAddr[fDev->nSectors]*2) ||
am29lvxxx.c:680:        ((offs + len) > fDev->sectAddr[fDev->nSectors]*2))
am29lvxxx.c:687:	if( h->flash_acc_size ) { /* access 16 bit data bus */
am29lvxxx.c:698:	if (fDev->devHdl->flashDev.devId == DEVCODE_29GL064A){
am29lvxxx.c:707:		/*--- issue command cycles ---*/
am29lvxxx.c:712:		if( h->flash_acc_size ) /* access 16 bit data bus */
am29lvxxx.c:718:		if(fDev->devHdl->flashDev.devId == DEVCODE_29GL064A)
am29lvxxx.c:731:		if (h->flash_acc_size )/* access 16 bit data bus */
am29lvxxx.c:733:			nWrite--;
am29lvxxx.c:736:			nWrite--;
am29lvxxx.c:753: *---------------------------------------------------------------------------
am29lvxxx.c:758:		Command( fDev->devHdl, 3, C_RESET );
am29lvxxx.c:765: *	for a 4-cycle command, issues the first 3 cycles\n
am29lvxxx.c:766: *  for a 6-cycle command, issues the first 5 cycles
am29lvxxx.c:768: *---------------------------------------------------------------------------
am29lvxxx.c:780:	if(h->dbgLevel)
am29lvxxx.c:782:			(int)h->flash_acc_size ));
am29lvxxx.c:784:	if( h->flash_acc_size ) { /* access 16 bit data bus */
am29lvxxx.c:791:	if (h->flashDev.devId == DEVCODE_29GL064A){
am29lvxxx.c:796:	/*--- issue command cycles ---*/
am29lvxxx.c:810: *---------------------------------------------------------------------------
am29lvxxx.c:833:		if(h->flash_acc_size) /* access 16 bit data bus */
am29lvxxx.c:834:			retVal = Z100_MREAD_D16( h->mappedAddr,
am29lvxxx.c:837:			retVal = Z100_MREAD_D8( h->mappedAddr,
am29lvxxx.c:841:		/*--- check state in DQ7 ---*/
am29lvxxx.c:843:			/*--- ready ---*/
am29lvxxx.c:845:		} else if( retVal & 0x20 ){ /*--- check state in DQ5 (timeout) ---*/
am29lvxxx.c:846:			/*--- recheck DQ7 ---*/
am29lvxxx.c:848:			if(h->flash_acc_size)/* access 16 bit data bus */
am29lvxxx.c:850:			    retVal2 = Z100_MREAD_D16( h->mappedAddr,
am29lvxxx.c:854:				retVal2 = Z100_MREAD_D8( h->mappedAddr,
am29lvxxx.c:858:				/*--- ready ---*/
am29lvxxx.c:880: *---------------------------------------------------------------------------
am29lvxxx.c:885: *  \return	sector number or error (-1) if not found
am29lvxxx.c:891:	addr &= (fDev->sectAddr[fDev->nSectors]*2 - 1);
am29lvxxx.c:893:	for( sect=0; sect < fDev->nSectors; sect++ ){
am29lvxxx.c:894:		if( addr >= fDev->sectAddr[sect]*2 &&
am29lvxxx.c:895:			addr < fDev->sectAddr[sect+1]*2){
am29lvxxx.c:896:			*phySizeP = (fDev->sectAddr[sect+1] - fDev->sectAddr[sect])*2;
am29lvxxx.c:900:	return -1;
DOC/html/men_stylesheet.css:2:	background-color: #ffffff;
DOC/html/men_stylesheet.css:4:	margin-left: 0pt;
DOC/html/men_stylesheet.css:5:	margin-right: 0pt;
DOC/html/men_stylesheet.css:6:	margin-top: 0pt;
DOC/html/men_stylesheet.css:7:	margin-bottom: 4pt;
DOC/html/men_stylesheet.css:9:	text-align: left;
DOC/html/men_stylesheet.css:10:	font-family: Verdana,Tahoma,Arial,Helvetica,Sans-Serif;
DOC/html/men_stylesheet.css:11:	font-size: 8pt;
DOC/html/men_stylesheet.css:12:	line-height: 11pt;
DOC/html/men_stylesheet.css:13:	font-weight: normal;
DOC/html/men_stylesheet.css:16:A { text-decoration: none; }
DOC/html/men_stylesheet.css:19:A:hover { text-decoration: underline; color: #c50038; }
DOC/html/men_stylesheet.css:25:	font-size: 8pt;
DOC/html/men_stylesheet.css:26:	font-weight: bold;
DOC/html/men_stylesheet.css:27:	font-family: Verdana,Tahoma,Arial,Helvetica,Univers,Sans Serif;
DOC/html/men_stylesheet.css:31:A.el { font-style: regular; }
DOC/html/men_stylesheet.css:32:A.elRef { font-style: regular; }
DOC/html/men_stylesheet.css:36:EM { font-style: italic; }
DOC/html/men_stylesheet.css:45:	text-align: left;
DOC/html/men_stylesheet.css:46:	margin-top: 3pt;
DOC/html/men_stylesheet.css:47:	margin-bottom: 3pt;
DOC/html/men_stylesheet.css:48:	margin-right: 0pt;
DOC/html/men_stylesheet.css:49:	margin-left: 0pt;
DOC/html/men_stylesheet.css:50:	font-size: 8pt;
DOC/html/men_stylesheet.css:51:	line-height: 10.5pt;
DOC/html/men_stylesheet.css:52:	font-weight: normal;
DOC/html/men_stylesheet.css:54:	font-family: Verdana,Tahoma,Arial,Helvetica,Sans-Serif;
DOC/html/men_stylesheet.css:59:	margin-top: 8px;
DOC/html/men_stylesheet.css:60:	margin-bottom: 8px;
DOC/html/men_stylesheet.css:61:	list-style-type: square;
DOC/html/men_stylesheet.css:65:	margin-top: 8px;
DOC/html/men_stylesheet.css:66:	margin-bottom: 8px;
DOC/html/men_stylesheet.css:70:	text-align: left;
DOC/html/men_stylesheet.css:71:	margin-top: 4px;
DOC/html/men_stylesheet.css:72:	margin-bottom: 4px;
DOC/html/men_stylesheet.css:73:	margin-left: -10px;
DOC/html/men_stylesheet.css:74:	margin-right: 0px;
DOC/html/men_stylesheet.css:76:	font-size: 8pt;
DOC/html/men_stylesheet.css:77:	font-weight: normal;
DOC/html/men_stylesheet.css:89:	margin-top: 10px;
DOC/html/men_stylesheet.css:90:	padding-left: 20px;
DOC/html/men_stylesheet.css:97:	margin-top: 20px;
DOC/html/men_stylesheet.css:98:	background-color: #F0F0F0;
DOC/html/men_stylesheet.css:99:	border-top: 2px solid #D1D1D2;
DOC/html/men_stylesheet.css:100:	padding-top: 5px;
DOC/html/men_stylesheet.css:101:	padding-bottom: 8px;
DOC/html/men_stylesheet.css:105:	margin-top: 0pt;
DOC/html/men_stylesheet.css:106:	margin-bottom: 0pt;
DOC/html/men_stylesheet.css:107:	margin-left: 3pt;
DOC/html/men_stylesheet.css:108:	margin-right: 0pt;
DOC/html/men_stylesheet.css:109:	font-size: 7pt;
DOC/html/men_stylesheet.css:110:	line-height: 8pt;
DOC/html/men_stylesheet.css:111:	font-weight: normal;
DOC/html/men_stylesheet.css:112:	font-style: Regular;
DOC/html/men_stylesheet.css:114:	font-family: Verdana,Tahoma,Arial,Helvetica,Sans-Serif;
DOC/html/men_stylesheet.css:117:DD { margin-left: 12pt; }
DOC/html/men_stylesheet.css:120:	text-align: left;
DOC/html/men_stylesheet.css:121:	margin-top: 7pt;
DOC/html/men_stylesheet.css:122:	margin-bottom: 6pt;
DOC/html/men_stylesheet.css:123:	margin-right: 0pt;
DOC/html/men_stylesheet.css:124:	margin-left: 0pt;
DOC/html/men_stylesheet.css:125:	font-size: 10pt;
DOC/html/men_stylesheet.css:126:	line-height: 12.5pt;
DOC/html/men_stylesheet.css:127:	font-weight: bold;
DOC/html/men_stylesheet.css:128:	font-style: Regular;
DOC/html/men_stylesheet.css:130:	font-family: Verdana,Tahoma,Arial,Helvetica,Sans-Serif;
DOC/html/men_stylesheet.css:134:	text-align: left;
DOC/html/men_stylesheet.css:135:	margin-top: 6pt;
DOC/html/men_stylesheet.css:136:	margin-bottom: 4pt;
DOC/html/men_stylesheet.css:137:	margin-right: 0pt;
DOC/html/men_stylesheet.css:138:	margin-left: 0pt;
DOC/html/men_stylesheet.css:139:	font-size: 9pt;
DOC/html/men_stylesheet.css:140:	font-weight: bold;
DOC/html/men_stylesheet.css:141:	font-style: Regular;
DOC/html/men_stylesheet.css:143:	font-family: Verdana,Tahoma,Arial,Helvetica,Sans-Serif;
DOC/html/men_stylesheet.css:147:	text-align: left;
DOC/html/men_stylesheet.css:148:	margin-top: 4pt;
DOC/html/men_stylesheet.css:149:	margin-bottom: 3pt;
DOC/html/men_stylesheet.css:150:	margin-right: 0pt;
DOC/html/men_stylesheet.css:151:	margin-left: 0pt;
DOC/html/men_stylesheet.css:152:	font-size: 8pt;
DOC/html/men_stylesheet.css:153:	font-weight: bold;
DOC/html/men_stylesheet.css:155:	vertical-align: top;
DOC/html/men_stylesheet.css:156:	font-family: Verdana,Tahoma,Arial,Helvetica,Sans-Serif;
DOC/html/men_stylesheet.css:159:	text-align: left;
DOC/html/men_stylesheet.css:160:	margin-top: 4pt;
DOC/html/men_stylesheet.css:161:	margin-bottom: 3pt;
DOC/html/men_stylesheet.css:162:	margin-right: 0pt;
DOC/html/men_stylesheet.css:163:	margin-left: 0pt;
DOC/html/men_stylesheet.css:164:	font-size: 8pt;
DOC/html/men_stylesheet.css:165:	font-weight: bold;
DOC/html/men_stylesheet.css:166:	font-style: italic;
DOC/html/men_stylesheet.css:168:	vertical-align: top;
DOC/html/men_stylesheet.css:169:	font-family: Verdana,Tahoma,Arial,Helvetica,Sans-Serif;
DOC/html/men_stylesheet.css:173:	font-family: Courier,Courier New;
DOC/html/men_stylesheet.css:174:	font-size: 9pt;
DOC/html/men_stylesheet.css:177:CAPTION { font-weight: bold }
DOC/html/men_stylesheet.css:179:DL.el { margin-left: -1cm }
DOC/html/men_stylesheet.css:180:DIV.fragment { width: 100%; padding-top: 5px; margin-top: 5px; border: 1px dotted #707072; }
DOC/html/men_stylesheet.css:182:DIV.ah { background-color: black; font-weight: bold; color: #ffffff; margin-bottom: 3px; margin-top: 3px }
DOC/html/men_stylesheet.css:183:DIV.groupHeader { margin-left: 16px; margin-top: 12px; margin-bottom: 6px; font-weight: bold }
DOC/html/men_stylesheet.css:184:DIV.groupText { margin-left: 16px; font-style: italic; font-size: smaller }
DOC/html/men_stylesheet.css:186:TABLE { spacing: 0; padding: 0; border-collapse: collapse; }
DOC/html/men_stylesheet.css:188:TD.md { background-color: #eaeaea; font-weight: bold; }
DOC/html/men_stylesheet.css:189:TD.mdname1 { background-color: #eaeaea; font-weight: bold; color: #666666; }
DOC/html/men_stylesheet.css:190:TD.mdname { background-color: #eaeaea; font-weight: bold; color: #666666; }
DOC/html/men_stylesheet.css:193:   background-color: #f1f1f1;
DOC/html/men_stylesheet.css:194:   font-weight: bold;
DOC/html/men_stylesheet.css:196:   margin-left: 0px;
DOC/html/men_stylesheet.css:197:   margin-right: 0px;
DOC/html/men_stylesheet.css:198:   margin-top: 2px;
DOC/html/men_stylesheet.css:199:   margin-bottom: 2px;
DOC/html/men_stylesheet.css:202:   background-color: #f1f1f1;
DOC/html/men_stylesheet.css:203:   font-style: regular;
DOC/html/men_stylesheet.css:205:   margin-left: 0px;
DOC/html/men_stylesheet.css:206:   margin-right: 0px;
DOC/html/men_stylesheet.css:207:   margin-top: 2px;
DOC/html/men_stylesheet.css:208:   margin-bottom: 2px;
DOC/html/fpga__load__doc_8c.html:1:<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
DOC/html/fpga__load__doc_8c.html:4:<title>MEN - Z100 FPGA update tool - fpga_load_doc.c File Reference</title>
DOC/html/fpga__load__doc_8c.html:5:<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
DOC/html/fpga__load__doc_8c.html:12:<div class="left_to_right" style="padding-top: 6px; background-color: #F0F0F0; height: 110px; border-bottom: 2px solid #D1D1D2;">
DOC/html/fpga__load__doc_8c.html:13:	<!-- Titel -->
DOC/html/fpga__load__doc_8c.html:15:	<h1 style="margin: 0px; padding-top: 35px; padding-bottom: 0px;">Z100 FPGA update tool &nbsp; </h1>
DOC/html/fpga__load__doc_8c.html:20:<!-- Hauptteil -->
DOC/html/fpga__load__doc_8c.html:22:<!-- Generated by Doxygen 1.3 -->
DOC/html/fpga__load__doc_8c.html:38:Required: -<p>
DOC/html/fpga__load__doc_8c.html:47:<!-- Footer -->
DOC/html/installdox:14:  if ( s/^-// ) {
DOC/html/installdox:23:          print STDERR "Unknown tag file $1 given with option -l\n";
DOC/html/installdox:27:        print STDERR "Argument $_ is invalid for option -l\n";
DOC/html/installdox:38:      print STDERR "Illegal option -$_\n";
DOC/html/installdox:112:  print STDERR "Usage: installdox [options] [html-file [html-file ...]]\n";
DOC/html/installdox:114:  print STDERR "     -l tagfile\@linkName   tag file + URL or directory \n";
DOC/html/installdox:115:  print STDERR "     -q                    Quiet mode\n\n";
DOC/html/pages.html:1:<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
DOC/html/pages.html:4:<title>MEN - Z100 FPGA update tool - Page Index</title>
DOC/html/pages.html:5:<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
DOC/html/pages.html:12:<div class="left_to_right" style="padding-top: 6px; background-color: #F0F0F0; height: 110px; border-bottom: 2px solid #D1D1D2;">
DOC/html/pages.html:13:	<!-- Titel -->
DOC/html/pages.html:15:	<h1 style="margin: 0px; padding-top: 35px; padding-bottom: 0px;">Z100 FPGA update tool &nbsp; </h1>
DOC/html/pages.html:20:<!-- Hauptteil -->
DOC/html/pages.html:22:<!-- Generated by Doxygen 1.3 -->
DOC/html/pages.html:36:<!-- Footer -->
DOC/html/struct__CHAM__ENT.html:1:<!-- Header -->
DOC/html/struct__CHAM__ENT.html:2:<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
DOC/html/struct__CHAM__ENT.html:5:<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
DOC/html/struct__CHAM__ENT.html:8:<title>MEN - Z100 FPGA update tool - _CHAM_ENT struct Reference</title>
DOC/html/struct__CHAM__ENT.html:15:	<!-- Titel -->
DOC/html/struct__CHAM__ENT.html:20:					<!-- Logo -->
DOC/html/struct__CHAM__ENT.html:26:						<h1 style="margin-top: 25pt; margin-bottom: 0pt;">Z100 FPGA update tool &nbsp; </h1>
DOC/html/struct__CHAM__ENT.html:34:	<!-- Haupttabelle -->
DOC/html/struct__CHAM__ENT.html:46:<!-- Generated by Doxygen 1.3 -->
DOC/html/struct__CHAM__ENT.html:243:<li><a class="el" href="fpga__load_8h-source.html">fpga_load.h</a></ul>
DOC/html/struct__CHAM__ENT.html:245:<!-- Footer -->
DOC/html/index.hhc:1:<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
DOC/html/fpga__load__os_8h.html:1:<!-- Header -->
DOC/html/fpga__load__os_8h.html:2:<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
DOC/html/fpga__load__os_8h.html:5:<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
DOC/html/fpga__load__os_8h.html:8:<title>MEN - Z100 FPGA update tool - fpga_load_os.h File Reference</title>
DOC/html/fpga__load__os_8h.html:15:	<!-- Titel -->
DOC/html/fpga__load__os_8h.html:20:					<!-- Logo -->
DOC/html/fpga__load__os_8h.html:26:						<h1 style="margin-top: 25pt; margin-bottom: 0pt;">Z100 FPGA update tool &nbsp; </h1>
DOC/html/fpga__load__os_8h.html:34:	<!-- Haupttabelle -->
DOC/html/fpga__load__os_8h.html:46:<!-- Generated by Doxygen 1.3 -->
DOC/html/fpga__load__os_8h.html:54:<a href="fpga__load__os_8h-source.html">Go to the source code of this file.</a><table border=0 cellpadding=0 cellspacing=0>
DOC/html/fpga__load__os_8h.html:275:<!-- Footer -->
DOC/html/index.html:1:<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
DOC/html/index.html:4:<title>MEN - Z100 FPGA update tool - Main Page</title>
DOC/html/index.html:5:<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
DOC/html/index.html:12:<div class="left_to_right" style="padding-top: 6px; background-color: #F0F0F0; height: 110px; border-bottom: 2px solid #D1D1D2;">
DOC/html/index.html:13:	<!-- Titel -->
DOC/html/index.html:15:	<h1 style="margin: 0px; padding-top: 35px; padding-bottom: 0px;">Z100 FPGA update tool &nbsp; </h1>
DOC/html/index.html:20:<!-- Hauptteil -->
DOC/html/index.html:22:<!-- Generated by Doxygen 1.3 -->
DOC/html/index.html:33:The FPGA_LOAD tool adapts at runtime to 8bit or 16bit FPGA-Flash interface and swapped or non-swapped versions.<p>
DOC/html/index.html:59:<!-- Footer -->
DOC/html/struct__PCI__DEVS.html:1:<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
DOC/html/struct__PCI__DEVS.html:4:<title>MEN - Z100 FPGA update tool - _PCI_DEVS struct Reference</title>
DOC/html/struct__PCI__DEVS.html:5:<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
DOC/html/struct__PCI__DEVS.html:12:<div class="left_to_right" style="padding-top: 6px; background-color: #F0F0F0; height: 110px; border-bottom: 2px solid #D1D1D2;">
DOC/html/struct__PCI__DEVS.html:13:	<!-- Titel -->
DOC/html/struct__PCI__DEVS.html:15:	<h1 style="margin: 0px; padding-top: 35px; padding-bottom: 0px;">Z100 FPGA update tool &nbsp; </h1>
DOC/html/struct__PCI__DEVS.html:20:<!-- Hauptteil -->
DOC/html/struct__PCI__DEVS.html:22:<!-- Generated by Doxygen 1.3 -->
DOC/html/struct__PCI__DEVS.html:44:<tr><td>&nbsp;</td><td><em class="mdesc">BAR0 - BAR5.</em> <a href="#m6"></a><em></em><br><br></td></tr>
DOC/html/struct__PCI__DEVS.html:73:BAR0 - BAR5.
DOC/html/struct__PCI__DEVS.html:271:<li><a class="el" href="fpga__load_8h-source.html">fpga_load.h</a></ul>
DOC/html/struct__PCI__DEVS.html:277:<!-- Footer -->
DOC/html/index.hhp:3:Full-text search=Yes
DOC/html/index.hhp:17:fpga__load_8h-source.html
DOC/html/index.hhp:18:fpga__load__flash_8h-source.html
DOC/html/index.hhp:19:maccess__io_8h-source.html
DOC/html/index.hhp:20:maccess__mem_8h-source.html
DOC/html/flash__com_8c.html:1:<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
DOC/html/flash__com_8c.html:4:<title>MEN - Z100 FPGA update tool - flash_com.c File Reference</title>
DOC/html/flash__com_8c.html:5:<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
DOC/html/flash__com_8c.html:12:<div class="left_to_right" style="padding-top: 6px; background-color: #F0F0F0; height: 110px; border-bottom: 2px solid #D1D1D2;">
DOC/html/flash__com_8c.html:13:	<!-- Titel -->
DOC/html/flash__com_8c.html:15:	<h1 style="margin: 0px; padding-top: 35px; padding-bottom: 0px;">Z100 FPGA update tool &nbsp; </h1>
DOC/html/flash__com_8c.html:20:<!-- Hauptteil -->
DOC/html/flash__com_8c.html:22:<!-- Generated by Doxygen 1.3 -->
DOC/html/flash__com_8c.html:41:Required: - <dl compact><dt><b>Preprocessor Switches:</b></dt><dd>(none)</dd></dl>
DOC/html/flash__com_8c.html:92:--------------------------------------------------------------------------- <dl compact><dt><b>Parameters:</b></dt><dd>
DOC/html/flash__com_8c.html:109:<!-- Footer -->
DOC/html/struct__FLASH__ENTRY.html:1:<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
DOC/html/struct__FLASH__ENTRY.html:4:<title>MEN - Z100 FPGA update tool - _FLASH_ENTRY struct Reference</title>
DOC/html/struct__FLASH__ENTRY.html:5:<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
DOC/html/struct__FLASH__ENTRY.html:12:<div class="left_to_right" style="padding-top: 6px; background-color: #F0F0F0; height: 110px; border-bottom: 2px solid #D1D1D2;">
DOC/html/struct__FLASH__ENTRY.html:13:	<!-- Titel -->
DOC/html/struct__FLASH__ENTRY.html:15:	<h1 style="margin: 0px; padding-top: 35px; padding-bottom: 0px;">Z100 FPGA update tool &nbsp; </h1>
DOC/html/struct__FLASH__ENTRY.html:20:<!-- Hauptteil -->
DOC/html/struct__FLASH__ENTRY.html:22:<!-- Generated by Doxygen 1.3 -->
DOC/html/struct__FLASH__ENTRY.html:193:<li><a class="el" href="fpga__load_8h-source.html">fpga_load.h</a></ul>
DOC/html/struct__FLASH__ENTRY.html:199:<!-- Footer -->
DOC/html/fpga__load__os_8h-source.html:1:<!-- Header -->
DOC/html/fpga__load__os_8h-source.html:2:<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
DOC/html/fpga__load__os_8h-source.html:5:<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
DOC/html/fpga__load__os_8h-source.html:8:<title>MEN - Z100 FPGA update tool - fpga_load_os.h Source File</title>
DOC/html/fpga__load__os_8h-source.html:15:	<!-- Titel -->
DOC/html/fpga__load__os_8h-source.html:20:					<!-- Logo -->
DOC/html/fpga__load__os_8h-source.html:26:						<h1 style="margin-top: 25pt; margin-bottom: 0pt;">Z100 FPGA update tool &nbsp; </h1>
DOC/html/fpga__load__os_8h-source.html:34:	<!-- Haupttabelle -->
DOC/html/fpga__load__os_8h-source.html:46:<!-- Generated by Doxygen 1.3 -->
DOC/html/fpga__load__os_8h-source.html:49:<hr><h1>fpga_load_os.h</h1><a href="fpga__load__os_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/***********************  I n c l u d e  -  F i l e  ***********************/</span>
DOC/html/fpga__load__os_8h-source.html:50:00014  <span class="comment">/*-------------------------------[ History ]--------------------------------</span>
DOC/html/fpga__load__os_8h-source.html:52:00016 <span class="comment"> * $Log: fpga__load__os_8h-source.html,v $
DOC/html/fpga__load__os_8h-source.html:54:00016 <span class="comment"> * (AUTOCI) Checkin due to new revision 1.1 of fileset ART/13Z100-60/13Z100-60
DOC/html/fpga__load__os_8h-source.html:60:00021 <span class="comment"> *---------------------------------------------------------------------------</span>
DOC/html/fpga__load__os_8h-source.html:94:00058 <span class="comment">/*-----------------------------------------+</span>
DOC/html/fpga__load__os_8h-source.html:96:00060 <span class="comment">+-----------------------------------------*/</span>
DOC/html/fpga__load__os_8h-source.html:117:<!-- Footer -->
DOC/html/structZ100MEM__MAPPED.html:1:<!-- Header -->
DOC/html/structZ100MEM__MAPPED.html:2:<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
DOC/html/structZ100MEM__MAPPED.html:5:<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
DOC/html/structZ100MEM__MAPPED.html:8:<title>MEN - Z100 FPGA update tool - Z100MEM_MAPPED struct Reference</title>
DOC/html/structZ100MEM__MAPPED.html:15:	<!-- Titel -->
DOC/html/structZ100MEM__MAPPED.html:20:					<!-- Logo -->
DOC/html/structZ100MEM__MAPPED.html:26:						<h1 style="margin-top: 25pt; margin-bottom: 0pt;">Z100 FPGA update tool &nbsp; </h1>
DOC/html/structZ100MEM__MAPPED.html:34:	<!-- Haupttabelle -->
DOC/html/structZ100MEM__MAPPED.html:46:<!-- Generated by Doxygen 1.3 -->
DOC/html/structZ100MEM__MAPPED.html:141:<!-- Footer -->
DOC/html/maccess__mem_8h-source.html:1:<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
DOC/html/maccess__mem_8h-source.html:4:<title>MEN - Z100 FPGA update tool - maccess_mem.h Source File</title>
DOC/html/maccess__mem_8h-source.html:5:<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
DOC/html/maccess__mem_8h-source.html:12:<div class="left_to_right" style="padding-top: 6px; background-color: #F0F0F0; height: 110px; border-bottom: 2px solid #D1D1D2;">
DOC/html/maccess__mem_8h-source.html:13:	<!-- Titel -->
DOC/html/maccess__mem_8h-source.html:15:	<h1 style="margin: 0px; padding-top: 35px; padding-bottom: 0px;">Z100 FPGA update tool &nbsp; </h1>
DOC/html/maccess__mem_8h-source.html:20:<!-- Hauptteil -->
DOC/html/maccess__mem_8h-source.html:22:<!-- Generated by Doxygen 1.3 -->
DOC/html/maccess__mem_8h-source.html:114:<!-- Footer -->
DOC/html/index.hhk:1:<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
DOC/html/maccess__io_8h.html:1:<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
DOC/html/maccess__io_8h.html:4:<title>MEN - Z100 FPGA update tool - maccess_io.h File Reference</title>
DOC/html/maccess__io_8h.html:5:<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
DOC/html/maccess__io_8h.html:12:<div class="left_to_right" style="padding-top: 6px; background-color: #F0F0F0; height: 110px; border-bottom: 2px solid #D1D1D2;">
DOC/html/maccess__io_8h.html:13:	<!-- Titel -->
DOC/html/maccess__io_8h.html:15:	<h1 style="margin: 0px; padding-top: 35px; padding-bottom: 0px;">Z100 FPGA update tool &nbsp; </h1>
DOC/html/maccess__io_8h.html:20:<!-- Hauptteil -->
DOC/html/maccess__io_8h.html:22:<!-- Generated by Doxygen 1.3 -->
DOC/html/maccess__io_8h.html:27:<a href="maccess__io_8h-source.html">Go to the source code of this file.</a><table border=0 cellpadding=0 cellspacing=0>
DOC/html/maccess__io_8h.html:314:<!-- Footer -->
Binary file DOC/html/doxygen.png matches
DOC/html/annotated.html:1:<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
DOC/html/annotated.html:4:<title>MEN - Z100 FPGA update tool - Annotated Index</title>
DOC/html/annotated.html:5:<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
DOC/html/annotated.html:12:<div class="left_to_right" style="padding-top: 6px; background-color: #F0F0F0; height: 110px; border-bottom: 2px solid #D1D1D2;">
DOC/html/annotated.html:13:	<!-- Titel -->
DOC/html/annotated.html:15:	<h1 style="margin: 0px; padding-top: 35px; padding-bottom: 0px;">Z100 FPGA update tool &nbsp; </h1>
DOC/html/annotated.html:20:<!-- Hauptteil -->
DOC/html/annotated.html:22:<!-- Generated by Doxygen 1.3 -->
DOC/html/annotated.html:37:<!-- Footer -->
DOC/html/functions.html:1:<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
DOC/html/functions.html:4:<title>MEN - Z100 FPGA update tool - Compound Member Index</title>
DOC/html/functions.html:5:<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
DOC/html/functions.html:12:<div class="left_to_right" style="padding-top: 6px; background-color: #F0F0F0; height: 110px; border-bottom: 2px solid #D1D1D2;">
DOC/html/functions.html:13:	<!-- Titel -->
DOC/html/functions.html:15:	<h1 style="margin: 0px; padding-top: 35px; padding-bottom: 0px;">Z100 FPGA update tool &nbsp; </h1>
DOC/html/functions.html:20:<!-- Hauptteil -->
DOC/html/functions.html:22:<!-- Generated by Doxygen 1.3 -->
DOC/html/functions.html:80:<!-- Footer -->
DOC/html/fpga__load__flash_8h.html:1:<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
DOC/html/fpga__load__flash_8h.html:4:<title>MEN - Z100 FPGA update tool - fpga_load_flash.h File Reference</title>
DOC/html/fpga__load__flash_8h.html:5:<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
DOC/html/fpga__load__flash_8h.html:12:<div class="left_to_right" style="padding-top: 6px; background-color: #F0F0F0; height: 110px; border-bottom: 2px solid #D1D1D2;">
DOC/html/fpga__load__flash_8h.html:13:	<!-- Titel -->
DOC/html/fpga__load__flash_8h.html:15:	<h1 style="margin: 0px; padding-top: 35px; padding-bottom: 0px;">Z100 FPGA update tool &nbsp; </h1>
DOC/html/fpga__load__flash_8h.html:20:<!-- Hauptteil -->
DOC/html/fpga__load__flash_8h.html:22:<!-- Generated by Doxygen 1.3 -->
DOC/html/fpga__load__flash_8h.html:30:<a href="fpga__load__flash_8h-source.html">Go to the source code of this file.</a><table border=0 cellpadding=0 cellspacing=0>
DOC/html/fpga__load__flash_8h.html:264:--------------------------------------------------------------------------- <dl compact><dt><b>Parameters:</b></dt><dd>
DOC/html/fpga__load__flash_8h.html:456:--------------------------------------------------------------------------- <dl compact><dt><b>Parameters:</b></dt><dd>
DOC/html/fpga__load__flash_8h.html:513:----------------------------------------------------------------------------- <dl compact><dt><b>Parameters:</b></dt><dd>
DOC/html/fpga__load__flash_8h.html:701:----------------------------------------------------------------------------- <dl compact><dt><b>Parameters:</b></dt><dd>
DOC/html/fpga__load__flash_8h.html:761:<!-- Footer -->
DOC/html/maccess__io_8h-source.html:1:<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
DOC/html/maccess__io_8h-source.html:4:<title>MEN - Z100 FPGA update tool - maccess_io.h Source File</title>
DOC/html/maccess__io_8h-source.html:5:<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
DOC/html/maccess__io_8h-source.html:12:<div class="left_to_right" style="padding-top: 6px; background-color: #F0F0F0; height: 110px; border-bottom: 2px solid #D1D1D2;">
DOC/html/maccess__io_8h-source.html:13:	<!-- Titel -->
DOC/html/maccess__io_8h-source.html:15:	<h1 style="margin: 0px; padding-top: 35px; padding-bottom: 0px;">Z100 FPGA update tool &nbsp; </h1>
DOC/html/maccess__io_8h-source.html:20:<!-- Hauptteil -->
DOC/html/maccess__io_8h-source.html:22:<!-- Generated by Doxygen 1.3 -->
DOC/html/maccess__io_8h-source.html:114:<!-- Footer -->
DOC/html/linux_8c.html:1:<!-- Header -->
DOC/html/linux_8c.html:2:<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
DOC/html/linux_8c.html:5:<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
DOC/html/linux_8c.html:8:<title>MEN - Z100 FPGA update tool - linux.c File Reference</title>
DOC/html/linux_8c.html:15:	<!-- Titel -->
DOC/html/linux_8c.html:20:					<!-- Logo -->
DOC/html/linux_8c.html:26:						<h1 style="margin-top: 25pt; margin-bottom: 0pt;">Z100 FPGA update tool &nbsp; </h1>
DOC/html/linux_8c.html:34:	<!-- Haupttabelle -->
DOC/html/linux_8c.html:46:<!-- Generated by Doxygen 1.3 -->
DOC/html/linux_8c.html:85:<dl compact><dt><b>Project:</b></dt><dd>13z100-91</dd></dl>
DOC/html/linux_8c.html:90:Required: - <dl compact><dt><b>Preprocessor Switches:</b></dt><dd>Z100_IO_MAPPED_EN: switch must not be set for PPC compilers</dd></dl>
DOC/html/linux_8c.html:239:<dl compact><dt><b>Returns:</b></dt><dd>success (0) or error (-1) or read value </dd></dl>
DOC/html/linux_8c.html:411:<dl compact><dt><b>Returns:</b></dt><dd>success (0) or error (-1) or read value </dd></dl>
DOC/html/linux_8c.html:519:<!-- Footer -->
DOC/html/struct__FLASH__DEVS.html:1:<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
DOC/html/struct__FLASH__DEVS.html:4:<title>MEN - Z100 FPGA update tool - _FLASH_DEVS struct Reference</title>
DOC/html/struct__FLASH__DEVS.html:5:<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
DOC/html/struct__FLASH__DEVS.html:12:<div class="left_to_right" style="padding-top: 6px; background-color: #F0F0F0; height: 110px; border-bottom: 2px solid #D1D1D2;">
DOC/html/struct__FLASH__DEVS.html:13:	<!-- Titel -->
DOC/html/struct__FLASH__DEVS.html:15:	<h1 style="margin: 0px; padding-top: 35px; padding-bottom: 0px;">Z100 FPGA update tool &nbsp; </h1>
DOC/html/struct__FLASH__DEVS.html:20:<!-- Hauptteil -->
DOC/html/struct__FLASH__DEVS.html:22:<!-- Generated by Doxygen 1.3 -->
DOC/html/struct__FLASH__DEVS.html:272:<li><a class="el" href="fpga__load_8h-source.html">fpga_load.h</a></ul>
DOC/html/struct__FLASH__DEVS.html:278:<!-- Footer -->
DOC/html/fpga__load_8h-source.html:1:<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
DOC/html/fpga__load_8h-source.html:4:<title>MEN - Z100 FPGA update tool - fpga_load.h Source File</title>
DOC/html/fpga__load_8h-source.html:5:<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
DOC/html/fpga__load_8h-source.html:12:<div class="left_to_right" style="padding-top: 6px; background-color: #F0F0F0; height: 110px; border-bottom: 2px solid #D1D1D2;">
DOC/html/fpga__load_8h-source.html:13:	<!-- Titel -->
DOC/html/fpga__load_8h-source.html:15:	<h1 style="margin: 0px; padding-top: 35px; padding-bottom: 0px;">Z100 FPGA update tool &nbsp; </h1>
DOC/html/fpga__load_8h-source.html:20:<!-- Hauptteil -->
DOC/html/fpga__load_8h-source.html:22:<!-- Generated by Doxygen 1.3 -->
DOC/html/fpga__load_8h-source.html:25:<hr><h1>fpga_load.h</h1><a href="fpga__load_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/***********************  I n c l u d e  -  F i l e  ***********************/</span>
DOC/html/fpga__load_8h-source.html:26:00017  <span class="comment">/*-------------------------------[ History ]--------------------------------</span>
DOC/html/fpga__load_8h-source.html:28:00019 <span class="comment"> * $Log: fpga__load_8h-source.html,v $
DOC/html/fpga__load_8h-source.html:30:00019 <span class="comment"> * (AUTOCI) Checkin due to new revision 1.16 of fileset ART/13Z100-06/13Z100-06
DOC/html/fpga__load_8h-source.html:102:00090 <span class="comment"> *---------------------------------------------------------------------------</span>
DOC/html/fpga__load_8h-source.html:113:00101 <span class="comment">/*-----------------------------------------+</span>
DOC/html/fpga__load_8h-source.html:115:00103 <span class="comment">+-----------------------------------------*/</span>
DOC/html/fpga__load_8h-source.html:170:00162 <span class="comment">/*-----------------------------------------+</span>
DOC/html/fpga__load_8h-source.html:172:00164 <span class="comment">+-----------------------------------------*/</span>
DOC/html/fpga__load_8h-source.html:194:00188 <span class="comment">/*--- boot sector position --*/</span>
DOC/html/fpga__load_8h-source.html:205:00199 <span class="comment">/*----- A500 Bus switches --- */</span>
DOC/html/fpga__load_8h-source.html:215:<a name="l00209"></a><a class="code" href="fpga__load_8h.html#a18">00209</a> <span class="preprocessor">#define LOG_TO_PHYS_ADDRREG(h) (h-&gt;pciDev.bar[h-&gt;bar] + h-&gt;addr_reg_offset)</span>
DOC/html/fpga__load_8h-source.html:216:<a name="l00210"></a><a class="code" href="fpga__load_8h.html#a19">00210</a> <span class="preprocessor"></span><span class="preprocessor">#define LOG_TO_PHYS_DATAREG(h) (h-&gt;pciDev.bar[h-&gt;bar] + h-&gt;data_reg_offset)</span>
DOC/html/fpga__load_8h-source.html:219:<a name="l00213"></a><a class="code" href="fpga__load_8h.html#a21">00213</a> <span class="preprocessor"></span><span class="preprocessor">#define MSECDIFF(basemsec)  (UOS_MsecTimerGet() - basemsec)</span>
DOC/html/fpga__load_8h-source.html:221:<a name="l00215"></a><a class="code" href="fpga__load_8h.html#a22">00215</a> <span class="preprocessor">#define Z100_MREAD_D8       h-&gt;Mread_D8</span>
DOC/html/fpga__load_8h-source.html:222:<a name="l00216"></a><a class="code" href="fpga__load_8h.html#a23">00216</a> <span class="preprocessor"></span><span class="preprocessor">#define Z100_MREAD_D16      h-&gt;Mread_D16</span>
DOC/html/fpga__load_8h-source.html:223:<a name="l00217"></a><a class="code" href="fpga__load_8h.html#a24">00217</a> <span class="preprocessor"></span><span class="preprocessor">#define Z100_MREAD_D32      h-&gt;Mread_D32</span>
DOC/html/fpga__load_8h-source.html:224:<a name="l00218"></a><a class="code" href="fpga__load_8h.html#a25">00218</a> <span class="preprocessor"></span><span class="preprocessor">#define Z100_MWRITE_D8      h-&gt;Mwrite_D8</span>
DOC/html/fpga__load_8h-source.html:225:<a name="l00219"></a><a class="code" href="fpga__load_8h.html#a26">00219</a> <span class="preprocessor"></span><span class="preprocessor">#define Z100_MWRITE_D16     h-&gt;Mwrite_D16</span>
DOC/html/fpga__load_8h-source.html:226:<a name="l00220"></a><a class="code" href="fpga__load_8h.html#a27">00220</a> <span class="preprocessor"></span><span class="preprocessor">#define Z100_MWRITE_D32     h-&gt;Mwrite_D32</span>
DOC/html/fpga__load_8h-source.html:227:<a name="l00221"></a><a class="code" href="fpga__load_8h.html#a28">00221</a> <span class="preprocessor"></span><span class="preprocessor">#define Z100_FLASH_WRITE    h-&gt;Write</span>
DOC/html/fpga__load_8h-source.html:228:<a name="l00222"></a><a class="code" href="fpga__load_8h.html#a29">00222</a> <span class="preprocessor"></span><span class="preprocessor">#define Z100_FLASH_READ     h-&gt;Read</span>
DOC/html/fpga__load_8h-source.html:230:00224 <span class="comment">/*-----------------------------------------------------------------------</span>
DOC/html/fpga__load_8h-source.html:232:00226 <span class="comment"> *----------------------------------------------------------------------*/</span>
DOC/html/fpga__load_8h-source.html:259:00253 <span class="comment">/*-----------------------------------------+</span>
DOC/html/fpga__load_8h-source.html:261:00255 <span class="comment">+-----------------------------------------*/</span>
DOC/html/fpga__load_8h-source.html:325:00342 <span class="comment">/*-----------------------------------------+</span>
DOC/html/fpga__load_8h-source.html:327:00344 <span class="comment">+-----------------------------------------*/</span>
DOC/html/fpga__load_8h-source.html:332:00349 <span class="comment">/*-----------------------------------------+</span>
DOC/html/fpga__load_8h-source.html:334:00351 <span class="comment">+-----------------------------------------*/</span>
DOC/html/fpga__load_8h-source.html:369:<!-- Footer -->
DOC/html/dummy.html:1:<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
DOC/html/dummy.html:4:<title>MEN - Z100 FPGA update tool - $title</title>
DOC/html/dummy.html:5:<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
DOC/html/dummy.html:12:<div class="left_to_right" style="padding-top: 6px; background-color: #F0F0F0; height: 110px; border-bottom: 2px solid #D1D1D2;">
DOC/html/dummy.html:13:	<!-- Titel -->
DOC/html/dummy.html:15:	<h1 style="margin: 0px; padding-top: 35px; padding-bottom: 0px;">Z100 FPGA update tool &nbsp; </h1>
DOC/html/dummy.html:20:<!-- Hauptteil -->
DOC/html/dummy.html:22:<!-- Generated by Doxygen 1.3 -->
DOC/html/dummy.html:33:<!-- Footer -->
DOC/html/vxworks_8c.html:1:<!-- Header -->
DOC/html/vxworks_8c.html:2:<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
DOC/html/vxworks_8c.html:5:<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
DOC/html/vxworks_8c.html:8:<title>MEN - Z100 FPGA update tool - vxworks.c File Reference</title>
DOC/html/vxworks_8c.html:15:	<!-- Titel -->
DOC/html/vxworks_8c.html:20:					<!-- Logo -->
DOC/html/vxworks_8c.html:26:						<h1 style="margin-top: 25pt; margin-bottom: 0pt;">Z100 FPGA update tool &nbsp; </h1>
DOC/html/vxworks_8c.html:34:	<!-- Haupttabelle -->
DOC/html/vxworks_8c.html:46:<!-- Generated by Doxygen 1.3 -->
DOC/html/vxworks_8c.html:73:<dl compact><dt><b>Project:</b></dt><dd>13z100-91</dd></dl>
DOC/html/vxworks_8c.html:78:Required: - Switches: Z100_IO_MAPPED_EN: switch must not be set for PPC compilers<hr><h2>Function Documentation</h2>
DOC/html/vxworks_8c.html:374:<!-- Footer -->
Binary file DOC/html/menlogo.gif matches
DOC/html/fpga__load_8h.html:1:<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
DOC/html/fpga__load_8h.html:4:<title>MEN - Z100 FPGA update tool - fpga_load.h File Reference</title>
DOC/html/fpga__load_8h.html:5:<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
DOC/html/fpga__load_8h.html:12:<div class="left_to_right" style="padding-top: 6px; background-color: #F0F0F0; height: 110px; border-bottom: 2px solid #D1D1D2;">
DOC/html/fpga__load_8h.html:13:	<!-- Titel -->
DOC/html/fpga__load_8h.html:15:	<h1 style="margin: 0px; padding-top: 35px; padding-bottom: 0px;">Z100 FPGA update tool &nbsp; </h1>
DOC/html/fpga__load_8h.html:20:<!-- Hauptteil -->
DOC/html/fpga__load_8h.html:22:<!-- Generated by Doxygen 1.3 -->
DOC/html/fpga__load_8h.html:30:<a href="fpga__load_8h-source.html">Go to the source code of this file.</a><table border=0 cellpadding=0 cellspacing=0>
DOC/html/fpga__load_8h.html:62:<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="fpga__load_8h.html#a18">LOG_TO_PHYS_ADDRREG</a>(h)&nbsp;&nbsp;&nbsp;(h-&gt;pciDev.bar[h-&gt;bar] + h-&gt;addr_reg_offset)</td></tr>
DOC/html/fpga__load_8h.html:63:<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="fpga__load_8h.html#a19">LOG_TO_PHYS_DATAREG</a>(h)&nbsp;&nbsp;&nbsp;(h-&gt;pciDev.bar[h-&gt;bar] + h-&gt;data_reg_offset)</td></tr>
DOC/html/fpga__load_8h.html:65:<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="fpga__load_8h.html#a21">MSECDIFF</a>(basemsec)&nbsp;&nbsp;&nbsp;(UOS_MsecTimerGet() - basemsec)</td></tr>
DOC/html/fpga__load_8h.html:66:<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="fpga__load_8h.html#a22">Z100_MREAD_D8</a>&nbsp;&nbsp;&nbsp;h-&gt;Mread_D8</td></tr>
DOC/html/fpga__load_8h.html:67:<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="fpga__load_8h.html#a23">Z100_MREAD_D16</a>&nbsp;&nbsp;&nbsp;h-&gt;Mread_D16</td></tr>
DOC/html/fpga__load_8h.html:68:<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="fpga__load_8h.html#a24">Z100_MREAD_D32</a>&nbsp;&nbsp;&nbsp;h-&gt;Mread_D32</td></tr>
DOC/html/fpga__load_8h.html:69:<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="fpga__load_8h.html#a25">Z100_MWRITE_D8</a>&nbsp;&nbsp;&nbsp;h-&gt;Mwrite_D8</td></tr>
DOC/html/fpga__load_8h.html:70:<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="fpga__load_8h.html#a26">Z100_MWRITE_D16</a>&nbsp;&nbsp;&nbsp;h-&gt;Mwrite_D16</td></tr>
DOC/html/fpga__load_8h.html:71:<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="fpga__load_8h.html#a27">Z100_MWRITE_D32</a>&nbsp;&nbsp;&nbsp;h-&gt;Mwrite_D32</td></tr>
DOC/html/fpga__load_8h.html:72:<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="fpga__load_8h.html#a28">Z100_FLASH_WRITE</a>&nbsp;&nbsp;&nbsp;h-&gt;Write</td></tr>
DOC/html/fpga__load_8h.html:73:<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="fpga__load_8h.html#a29">Z100_FLASH_READ</a>&nbsp;&nbsp;&nbsp;h-&gt;Read</td></tr>
DOC/html/fpga__load_8h.html:473:          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;(h-&gt;pciDev.bar[h-&gt;bar] + h-&gt;addr_reg_offset)
DOC/html/fpga__load_8h.html:500:          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;(h-&gt;pciDev.bar[h-&gt;bar] + h-&gt;data_reg_offset)
DOC/html/fpga__load_8h.html:554:          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;(UOS_MsecTimerGet() - basemsec)
DOC/html/fpga__load_8h.html:730:          <td class="md" nowrap valign="top"> #define Z100_FLASH_READ&nbsp;&nbsp;&nbsp;h-&gt;Read
DOC/html/fpga__load_8h.html:752:          <td class="md" nowrap valign="top"> #define Z100_FLASH_WRITE&nbsp;&nbsp;&nbsp;h-&gt;Write
DOC/html/fpga__load_8h.html:840:          <td class="md" nowrap valign="top"> #define Z100_MREAD_D16&nbsp;&nbsp;&nbsp;h-&gt;Mread_D16
DOC/html/fpga__load_8h.html:862:          <td class="md" nowrap valign="top"> #define Z100_MREAD_D32&nbsp;&nbsp;&nbsp;h-&gt;Mread_D32
DOC/html/fpga__load_8h.html:884:          <td class="md" nowrap valign="top"> #define Z100_MREAD_D8&nbsp;&nbsp;&nbsp;h-&gt;Mread_D8
DOC/html/fpga__load_8h.html:906:          <td class="md" nowrap valign="top"> #define Z100_MWRITE_D16&nbsp;&nbsp;&nbsp;h-&gt;Mwrite_D16
DOC/html/fpga__load_8h.html:928:          <td class="md" nowrap valign="top"> #define Z100_MWRITE_D32&nbsp;&nbsp;&nbsp;h-&gt;Mwrite_D32
DOC/html/fpga__load_8h.html:950:          <td class="md" nowrap valign="top"> #define Z100_MWRITE_D8&nbsp;&nbsp;&nbsp;h-&gt;Mwrite_D8
DOC/html/fpga__load_8h.html:1136:<!-- Footer -->
DOC/html/globals.html:1:<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
DOC/html/globals.html:4:<title>MEN - Z100 FPGA update tool - File Member Index</title>
DOC/html/globals.html:5:<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
DOC/html/globals.html:12:<div class="left_to_right" style="padding-top: 6px; background-color: #F0F0F0; height: 110px; border-bottom: 2px solid #D1D1D2;">
DOC/html/globals.html:13:	<!-- Titel -->
DOC/html/globals.html:15:	<h1 style="margin: 0px; padding-top: 35px; padding-bottom: 0px;">Z100 FPGA update tool &nbsp; </h1>
DOC/html/globals.html:20:<!-- Hauptteil -->
DOC/html/globals.html:22:<!-- Generated by Doxygen 1.3 -->
DOC/html/globals.html:236:<!-- Footer -->
DOC/html/am29lvxxx_8c.html:1:<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
DOC/html/am29lvxxx_8c.html:4:<title>MEN - Z100 FPGA update tool - am29lvxxx.c File Reference</title>
DOC/html/am29lvxxx_8c.html:5:<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
DOC/html/am29lvxxx_8c.html:12:<div class="left_to_right" style="padding-top: 6px; background-color: #F0F0F0; height: 110px; border-bottom: 2px solid #D1D1D2;">
DOC/html/am29lvxxx_8c.html:13:	<!-- Titel -->
DOC/html/am29lvxxx_8c.html:15:	<h1 style="margin: 0px; padding-top: 35px; padding-bottom: 0px;">Z100 FPGA update tool &nbsp; </h1>
DOC/html/am29lvxxx_8c.html:20:<!-- Hauptteil -->
DOC/html/am29lvxxx_8c.html:22:<!-- Generated by Doxygen 1.3 -->
DOC/html/am29lvxxx_8c.html:93:Required: - <dl compact><dt><b>Preprocessor Switches:</b></dt><dd>(none)</dd></dl>
DOC/html/am29lvxxx_8c.html:718:--------------------------------------------------------------------------- <dl compact><dt><b>Parameters:</b></dt><dd>
DOC/html/am29lvxxx_8c.html:723:<dl compact><dt><b>Returns:</b></dt><dd>ptr to entry into FLASH_DEVS or NULL if not found Globals....: - </dd></dl>
DOC/html/am29lvxxx_8c.html:770:for a 4-cycle command, issues the first 3 cycles<br>
DOC/html/am29lvxxx_8c.html:771: for a 6-cycle command, issues the first 5 cycles<p>
DOC/html/am29lvxxx_8c.html:772:--------------------------------------------------------------------------- <dl compact><dt><b>Parameters:</b></dt><dd>
DOC/html/am29lvxxx_8c.html:831:--------------------------------------------------------------------------- <dl compact><dt><b>Parameters:</b></dt><dd>
DOC/html/am29lvxxx_8c.html:871:--------------------------------------------------------------------------- <dl compact><dt><b>Parameters:</b></dt><dd>
DOC/html/am29lvxxx_8c.html:923:--------------------------------------------------------------------------- <dl compact><dt><b>Parameters:</b></dt><dd>
DOC/html/am29lvxxx_8c.html:962:--------------------------------------------------------------------------- <dl compact><dt><b>Parameters:</b></dt><dd>
DOC/html/am29lvxxx_8c.html:1014:--------------------------------------------------------------------------- <dl compact><dt><b>Parameters:</b></dt><dd>
DOC/html/am29lvxxx_8c.html:1021:<dl compact><dt><b>Returns:</b></dt><dd>sector number or error (-1) if not found </dd></dl>
DOC/html/am29lvxxx_8c.html:1054:--------------------------------------------------------------------------- <dl compact><dt><b>Parameters:</b></dt><dd>
DOC/html/am29lvxxx_8c.html:1091:--------------------------------------------------------------------------- <dl compact><dt><b>Parameters:</b></dt><dd>
DOC/html/am29lvxxx_8c.html:1129:--------------------------------------------------------------------------- <dl compact><dt><b>Parameters:</b></dt><dd>
DOC/html/am29lvxxx_8c.html:1186:--------------------------------------------------------------------------- <dl compact><dt><b>Parameters:</b></dt><dd>
DOC/html/am29lvxxx_8c.html:1243:--------------------------------------------------------------------------- <dl compact><dt><b>Parameters:</b></dt><dd>
DOC/html/am29lvxxx_8c.html:1282:<!-- Footer -->
DOC/html/struct__DEV__HDL.html:1:<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
DOC/html/struct__DEV__HDL.html:4:<title>MEN - Z100 FPGA update tool - _DEV_HDL struct Reference</title>
DOC/html/struct__DEV__HDL.html:5:<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
DOC/html/struct__DEV__HDL.html:12:<div class="left_to_right" style="padding-top: 6px; background-color: #F0F0F0; height: 110px; border-bottom: 2px solid #D1D1D2;">
DOC/html/struct__DEV__HDL.html:13:	<!-- Titel -->
DOC/html/struct__DEV__HDL.html:15:	<h1 style="margin: 0px; padding-top: 35px; padding-bottom: 0px;">Z100 FPGA update tool &nbsp; </h1>
DOC/html/struct__DEV__HDL.html:20:<!-- Hauptteil -->
DOC/html/struct__DEV__HDL.html:22:<!-- Generated by Doxygen 1.3 -->
DOC/html/struct__DEV__HDL.html:609:<li><a class="el" href="fpga__load_8h-source.html">fpga_load.h</a></ul>
DOC/html/struct__DEV__HDL.html:615:<!-- Footer -->
DOC/html/files.html:1:<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
DOC/html/files.html:4:<title>MEN - Z100 FPGA update tool - File Index</title>
DOC/html/files.html:5:<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
DOC/html/files.html:12:<div class="left_to_right" style="padding-top: 6px; background-color: #F0F0F0; height: 110px; border-bottom: 2px solid #D1D1D2;">
DOC/html/files.html:13:	<!-- Titel -->
DOC/html/files.html:15:	<h1 style="margin: 0px; padding-top: 35px; padding-bottom: 0px;">Z100 FPGA update tool &nbsp; </h1>
DOC/html/files.html:20:<!-- Hauptteil -->
DOC/html/files.html:22:<!-- Generated by Doxygen 1.3 -->
DOC/html/files.html:30:  <tr><td class="indexkey"><a class="el" href="__istrata__mmod__stub_8c.html">_istrata_mmod_stub.c</a></td><td class="indexvalue">Instance for IntelStrata Flash m-module version</td></tr>
DOC/html/files.html:31:  <tr><td class="indexkey"><a class="el" href="__istrata__mmod__sw__stub_8c.html">_istrata_mmod_sw_stub.c</a></td><td class="indexvalue">Instance for IntelStrata Flash swapped m-module version</td></tr>
DOC/html/files.html:40:  <tr><td class="indexkey"><a class="el" href="fpga__load_8h.html">fpga_load.h</a> <a href="fpga__load_8h-source.html">[code]</a></td><td class="indexvalue">Header file for FPGA_LOAD tool containing: specific function prototypes, specific type definitions</td></tr>
DOC/html/files.html:42:  <tr><td class="indexkey"><a class="el" href="fpga__load__flash_8h.html">fpga_load_flash.h</a> <a href="fpga__load__flash_8h-source.html">[code]</a></td><td class="indexvalue">Header file for FPGA_LOAD tool containing Flash specific functions</td></tr>
DOC/html/files.html:47:  <tr><td class="indexkey"><a class="el" href="maccess__io_8h.html">maccess_io.h</a> <a href="maccess__io_8h-source.html">[code]</a></td><td class="indexvalue"></td></tr>
DOC/html/files.html:48:  <tr><td class="indexkey"><a class="el" href="maccess__mem_8h.html">maccess_mem.h</a> <a href="maccess__mem_8h-source.html">[code]</a></td><td class="indexvalue"></td></tr>
DOC/html/files.html:56:<!-- Footer -->
DOC/html/fpga__load__flash_8h-source.html:1:<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
DOC/html/fpga__load__flash_8h-source.html:4:<title>MEN - Z100 FPGA update tool - fpga_load_flash.h Source File</title>
DOC/html/fpga__load__flash_8h-source.html:5:<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
DOC/html/fpga__load__flash_8h-source.html:12:<div class="left_to_right" style="padding-top: 6px; background-color: #F0F0F0; height: 110px; border-bottom: 2px solid #D1D1D2;">
DOC/html/fpga__load__flash_8h-source.html:13:	<!-- Titel -->
DOC/html/fpga__load__flash_8h-source.html:15:	<h1 style="margin: 0px; padding-top: 35px; padding-bottom: 0px;">Z100 FPGA update tool &nbsp; </h1>
DOC/html/fpga__load__flash_8h-source.html:20:<!-- Hauptteil -->
DOC/html/fpga__load__flash_8h-source.html:22:<!-- Generated by Doxygen 1.3 -->
DOC/html/fpga__load__flash_8h-source.html:25:<hr><h1>fpga_load_flash.h</h1><a href="fpga__load__flash_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/***********************  I n c l u d e  -  F i l e  ***********************/</span>
DOC/html/fpga__load__flash_8h-source.html:26:00014  <span class="comment">/*-------------------------------[ History ]--------------------------------</span>
DOC/html/fpga__load__flash_8h-source.html:28:00016 <span class="comment"> * $Log: fpga__load__flash_8h-source.html,v $
DOC/html/fpga__load__flash_8h-source.html:30:00016 <span class="comment"> * (AUTOCI) Checkin due to new revision 1.16 of fileset ART/13Z100-06/13Z100-06
DOC/html/fpga__load__flash_8h-source.html:36:00021 <span class="comment"> * added: Try-functions for the swapped versions</span>
DOC/html/fpga__load__flash_8h-source.html:49:00034 <span class="comment"> *---------------------------------------------------------------------------</span>
DOC/html/fpga__load__flash_8h-source.html:60:00045 <span class="comment">/*-----------------------------------------+</span>
DOC/html/fpga__load__flash_8h-source.html:62:00047 <span class="comment">+-----------------------------------------*/</span>
DOC/html/fpga__load__flash_8h-source.html:68:00053 <span class="comment">/*-----------------------------------------+</span>
DOC/html/fpga__load__flash_8h-source.html:70:00055 <span class="comment">+-----------------------------------------*/</span>
DOC/html/fpga__load__flash_8h-source.html:72:00057 <span class="comment">/*-----------------------------------------+</span>
DOC/html/fpga__load__flash_8h-source.html:74:00059 <span class="comment">+-----------------------------------------*/</span>
DOC/html/fpga__load__flash_8h-source.html:133:<!-- Footer -->
DOC/html/fpga__load_8c.html:1:<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
DOC/html/fpga__load_8c.html:4:<title>MEN - Z100 FPGA update tool - fpga_load.c File Reference</title>
DOC/html/fpga__load_8c.html:5:<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
DOC/html/fpga__load_8c.html:12:<div class="left_to_right" style="padding-top: 6px; background-color: #F0F0F0; height: 110px; border-bottom: 2px solid #D1D1D2;">
DOC/html/fpga__load_8c.html:13:	<!-- Titel -->
DOC/html/fpga__load_8c.html:15:	<h1 style="margin: 0px; padding-top: 35px; padding-bottom: 0px;">Z100 FPGA update tool &nbsp; </h1>
DOC/html/fpga__load_8c.html:20:<!-- Hauptteil -->
DOC/html/fpga__load_8c.html:22:<!-- Generated by Doxygen 1.3 -->
DOC/html/fpga__load_8c.html:31:<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="fpga__load_8c.html#a0">FPGA_P_HELP</a>&nbsp;&nbsp;&nbsp;"           type fpga_load -h for help\n"</td></tr>
DOC/html/fpga__load_8c.html:98:Required: uti.l (under OS-9), libuti.a (under Linux)<hr><h2>Define Documentation</h2>
DOC/html/fpga__load_8c.html:105:          <td class="md" nowrap valign="top"> #define FPGA_P_HELP&nbsp;&nbsp;&nbsp;"           type fpga_load -h for help\n"
DOC/html/fpga__load_8c.html:274:<dl compact><dt><b>Returns:</b></dt><dd>success (number of parameters used from command line) or error (-error) </dd></dl>
DOC/html/fpga__load_8c.html:335:<dl compact><dt><b>Returns:</b></dt><dd>success (number of parameters used from command line) or error (-error) </dd></dl>
DOC/html/fpga__load_8c.html:388:--------------------------------------------------------------------------- <dl compact><dt><b>Parameters:</b></dt><dd>
DOC/html/fpga__load_8c.html:396:<dl compact><dt><b>Returns:</b></dt><dd>sector number or error (-1) if not found </dd></dl>
DOC/html/fpga__load_8c.html:464:<dl compact><dt><b>Returns:</b></dt><dd>success (0) or error (-1) or read value </dd></dl>
DOC/html/fpga__load_8c.html:553:<dl compact><dt><b>Returns:</b></dt><dd>0 on success or -1 if failed </dd></dl>
DOC/html/fpga__load_8c.html:612:<dl compact><dt><b>Returns:</b></dt><dd>file size or error (-1) </dd></dl>
DOC/html/fpga__load_8c.html:717:    <tr><td valign=top><em>flashInterf</em>&nbsp;</td><td><b>IN</b> 0 - Z045_FLASH, 1 - PLD/SMB</td></tr>
DOC/html/fpga__load_8c.html:875:<dl compact><dt><b>Returns:</b></dt><dd>success (0) or error (-1) </dd></dl>
DOC/html/fpga__load_8c.html:942:<dl compact><dt><b>Returns:</b></dt><dd>success (number of parameters used from command line) or error (-error) </dd></dl>
DOC/html/fpga__load_8c.html:1011:<dl compact><dt><b>Returns:</b></dt><dd>success (number of parameters used from command line) or error (-error) </dd></dl>
DOC/html/fpga__load_8c.html:1049:<dl compact><dt><b>Returns:</b></dt><dd>- </dd></dl>
DOC/html/fpga__load_8c.html:1116:<dl compact><dt><b>Returns:</b></dt><dd>success (number of parameters used from command line) or error (-error)</dd></dl>
DOC/html/fpga__load_8c.html:1282:<dl compact><dt><b>Returns:</b></dt><dd>success (number of parameters used from command line) or error (-error)</dd></dl>
DOC/html/fpga__load_8c.html:1763:<!-- Footer -->
DOC/html/maccess__mem_8h.html:1:<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
DOC/html/maccess__mem_8h.html:4:<title>MEN - Z100 FPGA update tool - maccess_mem.h File Reference</title>
DOC/html/maccess__mem_8h.html:5:<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
DOC/html/maccess__mem_8h.html:12:<div class="left_to_right" style="padding-top: 6px; background-color: #F0F0F0; height: 110px; border-bottom: 2px solid #D1D1D2;">
DOC/html/maccess__mem_8h.html:13:	<!-- Titel -->
DOC/html/maccess__mem_8h.html:15:	<h1 style="margin: 0px; padding-top: 35px; padding-bottom: 0px;">Z100 FPGA update tool &nbsp; </h1>
DOC/html/maccess__mem_8h.html:20:<!-- Hauptteil -->
DOC/html/maccess__mem_8h.html:22:<!-- Generated by Doxygen 1.3 -->
DOC/html/maccess__mem_8h.html:27:<a href="maccess__mem_8h-source.html">Go to the source code of this file.</a><table border=0 cellpadding=0 cellspacing=0>
DOC/html/maccess__mem_8h.html:314:<!-- Footer -->
fpga_load.c:13: *     Required: uti.l (under OS-9), libuti.a (under Linux)
fpga_load.c:18: *-----------------------------------------------------------------------------
fpga_load.c:19: * (c) Copyright 2004-2005 by MEN Mikro Elektronik GmbH, Nuremberg, Germany
fpga_load.c:46:/*-----------------------------------------+
fpga_load.c:48: +-----------------------------------------*/
fpga_load.c:88:/*-----------------------------------------+
fpga_load.c:90: +-----------------------------------------*/
fpga_load.c:91:#define FPGA_P_HELP "           type fpga_load -h for help\n"
fpga_load.c:109:/*-----------------------------------------+
fpga_load.c:111: +-----------------------------------------*/
fpga_load.c:112:/*-----------------------------------------+
fpga_load.c:114: +-----------------------------------------*/
fpga_load.c:217:			" options -b/-o (PCI), -a (VME), -d (ISA/LPC).\n"
fpga_load.c:218:			" Without option -b/-o (PCI) or with option -k (ISA/LPC), the\n"
fpga_load.c:223:			" ----- PCIbus -----\n"
fpga_load.c:224:			" <vendor-id>         PCI vendor ID (e.g. 0x1172)\n"
fpga_load.c:225:			" <device-id>         PCI device ID (e.g. 0x4D45 for chameleon_2 dev)\n"
fpga_load.c:226:			" <sub-vendor-id>     PCI subsystem vendor ID (e.g. 0x0007 for 15P018)\n"
fpga_load.c:227:			" <instance-nbr>      instance number of PCI Chameleon FPGA (see -s)\n"
fpga_load.c:228:			" [-b <bar>           PCI BAR number 0..5\n"
fpga_load.c:229:			"  -o <offset>]       offset from specified BAR to flash interface\n"
fpga_load.c:230:			" -s                  only show all PCI device instances that match to\n"
fpga_load.c:231:			"                      <vendor-id>, <device-id>, <sub-vendor-id>\n"
fpga_load.c:233:			" -i <offset>         CPU to PCI io-mapped offset                           [0x0]\n"
fpga_load.c:234:			" -m <offset>         CPU to PCI memory-mapped offset                       [0x0]\n"
fpga_load.c:235:			" -g=<PCI domain>     #of PCI ctrl. to use (PCI domain). currently only A21 [0x0]\n"
fpga_load.c:238:			"----- MMODbus -----\n"
fpga_load.c:239:			" -q                  change the access type to work with MMOD A8D16 mode\n"
fpga_load.c:241:			"----- VMEbus -----\n"
fpga_load.c:242:			" -a <VME-addr>       directly specify VME address of flash interface\n"
fpga_load.c:244:			"----- ISA/LPC -----\n"
fpga_load.c:245:			" -d <addr>           directly specify address of flash interface,\n"
fpga_load.c:246:			"		              !!!ATTENTION: No flash type validation, please specify -z or -j.\n"
fpga_load.c:248:			" -k <tbl-addr>       use Chameleon table at specified address,\n"
fpga_load.c:252:			" -z                  use only SPI Flashes with 16Z126 flash Interface\n"
fpga_load.c:253:			" -j		      use only Parallel Flashes\n"
fpga_load.c:255:			" -p <SMB-ctrlr>      use SMB flash interface instead of 16Z045_FLASH,\n"
fpga_load.c:256:			"                      list of supported SMB-ctrlr:\n"
fpga_load.c:261:			" -u <file> <nr>      update FPGA config Nr. <0-3> in flash\n"
fpga_load.c:265:			" -r <start> <len>    read <len> bytes from the flash at offset <start>\n"
fpga_load.c:268:			" -l                  load new FPGA config at end                          [FALSE]\n"
fpga_load.c:271:			" -f <force-cmd>       switch to force moden, (use one of the cmds below)\n"
fpga_load.c:273:			"                       - no header validation will be performed\n"
fpga_load.c:274:			"                       - all options must be passed by command line\n"
fpga_load.c:275:			"                       - full access to flash commands is granted\n"
fpga_load.c:276:			"                       - more than one command can be passed\n"
fpga_load.c:278:			"   -c                  erase chip\n"
fpga_load.c:279:			"   -e <start> <len>    erase complete blocks, starting with the block\n"
fpga_load.c:282:			"   -w <file> <start>   write <file> to the flash, starting at offset\n"
fpga_load.c:286:			" -x <z>              set bus switches of A500 ESM carrier\n"
fpga_load.c:292:			"    -t                shows the chameleon table                           [no]\n"
fpga_load.c:293:			"    -n                version information                                 [no]\n"
fpga_load.c:294:			"    -v                verbose mode                                        [no]\n"
fpga_load.c:295:			"    -h / -?           print this help                                     [no]\n"
fpga_load.c:299:			"		Dump Chameleon Table: fpga_load -k 0xe000e000 -t\n"
fpga_load.c:300:			"		Program FPGA File:    fpga_load -k 0xe000e000 -z -f -w <filename> 80000\n"
fpga_load.c:302:			"		Dump Chameleon Table: fpga_load 1a88 4d45 b3 0 -t\n"
fpga_load.c:303:			"		Program FPGA File:	  fpga_load 1a88 4d45 b3 0 -z -f -w <filename.rbf> 0\n"
fpga_load.c:308:		   "(c) 2004-2013 MEN Mikro Elektronik GmbH. File revision:\n%s",RCSid);
fpga_load.c:372:	G_pHga = &osHdl->pciGenDevice;
fpga_load.c:386:	h->flashDev.devHdl = h;
fpga_load.c:413:	h->dbgLevel	  = (UTL_TSTOPT("v") ? 1 : 0);
fpga_load.c:415:	if( h->dbgLevel )
fpga_load.c:426:		h->smbLocHdl.smbCtlName[0] = 0;
fpga_load.c:429:			if( !strcmp( "-p", *largv ) ) {
fpga_load.c:431:					(!sscanf(largv[1],"%u",(unsigned int*)&h->smbLocHdl.smbCtlNum) &&
fpga_load.c:432:					 !sscanf(largv[1],"%s",h->smbLocHdl.smbCtlName)) )
fpga_load.c:434:					printf("*** ERROR: option -p requires type/number of SMB "
fpga_load.c:441:			largc--;
fpga_load.c:468:		h->interfacemmod = 1;
fpga_load.c:473:		h->interfacespi = 1;
fpga_load.c:476:		h->interfacespi = 0;
fpga_load.c:478:		printf("*** ERROR: please specify the flash type (-j or -z)\n");
fpga_load.c:485:	if( !flashInterf || *h->smbLocHdl.smbCtlName ) {
fpga_load.c:499:				if ( !strcmp( "-d", *largv )) {
fpga_load.c:503:						printf("*** ERROR: option -d requires address as hex value\n"
fpga_load.c:510:    			largc--;
fpga_load.c:514:			h->physAddr = (void *)(BusAddr & ~0x1);
fpga_load.c:515:			h->busType  = OSS_BUSTYPE_NONE;
fpga_load.c:521:				h->mapType = OSS_ADDRSPACE_IO;
fpga_load.c:524:				h->mapType  = OSS_ADDRSPACE_MEM;
fpga_load.c:561:			if( !strcmp( "-u", *largv ) ) {
fpga_load.c:565:			largc--;
fpga_load.c:578:			if( !strcmp( "-r", *largv ) )
fpga_load.c:585:			largc--;
fpga_load.c:597:			if( !strcmp( "-x", *largv ) ) {
fpga_load.c:604:			largc--;
fpga_load.c:616:			if( !strcmp( "-f", *argv ) ) {
fpga_load.c:619:			argc--;
fpga_load.c:625:		if( !strcmp( "-l", *argv ) ) {
fpga_load.c:627:			argc--;
fpga_load.c:632:		if( !strcmp( "-c", *argv ) ) {
fpga_load.c:635:				argc -= rc;
fpga_load.c:644:		if( !strcmp( "-e", *argv ) ) {
fpga_load.c:647:				argc -= rc;
fpga_load.c:656:		if( !strcmp( "-r", *argv ) ) {
fpga_load.c:659:				argc -= rc;
fpga_load.c:668:		if( !strcmp( "-w", *argv ) ) {
fpga_load.c:671:				argc -= rc;
fpga_load.c:681:		if( !strcmp( "-i", *argv ) ||
fpga_load.c:682:			!strcmp( "-m", *argv ) ) { /* ignore -i and -m option here */
fpga_load.c:683:			argc -= 2;
fpga_load.c:689:		if( !strcmp( "-v", *argv ) ) { /* ignore -v option here */
fpga_load.c:690:			argc--;
fpga_load.c:695:		argc--; argv++;
fpga_load.c:703:		if( h->flashDev.isInit  )
fpga_load.c:704:			h->flash_entry.Exit(&h->flashDev);
fpga_load.c:706:		if( h->smbLocHdl.smbHdl )
fpga_load.c:709:		if( h->mappedAddr ) {
fpga_load.c:720:								  (void**)&h->mappedAddr,
fpga_load.c:721:								  h->mappedSize,
fpga_load.c:722:								  h->mapType);
fpga_load.c:743: *  \return	          success (0) or error (-1)
fpga_load.c:748:		return -1;
fpga_load.c:761: * 					or error (-error)
fpga_load.c:768:	if( h->dbgLevel )
fpga_load.c:771:	h->flash_entry.Reset(&h->flashDev);
fpga_load.c:772:	error = h->flash_entry.EraseChip(&h->flashDev);
fpga_load.c:774:	if( h->dbgLevel && !error )
fpga_load.c:775:		printf("----> OK: Chip Erased\n\n");
fpga_load.c:789: * 					or error (-error)
fpga_load.c:797:	if( h->dbgLevel )
fpga_load.c:803:		printf("\n*** ERROR: -e requires address in the sector to erase first\n"
fpga_load.c:810:	h->flash_entry.Reset(&h->flashDev);
fpga_load.c:815:	if((error = h->flash_entry.EraseSectors(&h->flashDev, startOffs, len)))
fpga_load.c:820:		h->flash_entry.Reset(&h->flashDev);
fpga_load.c:834: * 					or error (-error)
fpga_load.c:849:	if( h->dbgLevel )
fpga_load.c:855:		printf("\n*** ERROR: Option -r requires at least "
fpga_load.c:860:				*argv[3] != '-' &&
fpga_load.c:874:	h->flash_entry.ReadBlock(&h->flashDev, startOffset, len, buf);
fpga_load.c:879:		else if( h->dbgLevel )
fpga_load.c:898:		h->flash_entry.Reset(&h->flashDev);
fpga_load.c:916: * 					or error (-error)
fpga_load.c:937:	if( h->dbgLevel )
fpga_load.c:941:		printf("\n*** ERROR: Option -w requires at least the file to be loaded\n");
fpga_load.c:958:		printf("\n*** ERROR: Option -w requires offset\n");
fpga_load.c:964:	if( h->dbgLevel )
fpga_load.c:967:	if( (error = h->flash_entry.EraseSectors( &h->flashDev, startOffset,
fpga_load.c:970:	else if( h->dbgLevel )
fpga_load.c:971:		printf("  ----> OK\n\n");
fpga_load.c:973:	h->flash_entry.Reset(&h->flashDev);
fpga_load.c:974:	if( h->dbgLevel )
fpga_load.c:977:    if( (error = h->flash_entry.WriteBlock( &h->flashDev,
fpga_load.c:986:	h->flash_entry.Reset(&h->flashDev);
fpga_load.c:995:	h->flash_entry.Reset(&h->flashDev);
fpga_load.c:1003:		h->flash_entry.Reset(&h->flashDev);
fpga_load.c:1017: *	\return -
fpga_load.c:1022:	if( h->mapType )
fpga_load.c:1024:		Z100_Mwrite_Io_D32( h->mappedAddr,
fpga_load.c:1031:		Z100_MWRITE_D32( h->mappedAddr,
fpga_load.c:1045: * 					or error (-error)
fpga_load.c:1062:	if( h->dbgLevel )
fpga_load.c:1066:		printf("\n*** ERROR: option -u requires filename (see \"fpga_load -h\")\n");
fpga_load.c:1089:	if( h->interfacespi ){
fpga_load.c:1103:		Get_FpgaHeader( &h->flashDev, 0x00, &header );
fpga_load.c:1119:	if( Z100_SWAP_BE32(headerP1->magic) != FPGA_LONGHEADER_MAGIC ) {
fpga_load.c:1124:	if( strcmp(header.boardType, headerP1->boardType) ) {
fpga_load.c:1136:		for( xor=0,i=0; i<(fileSize-FPGA_SIZE_HEADER_LONG)/4; i++ )
fpga_load.c:1141:		if( headerP1->chksum != xor ) {
fpga_load.c:1152:	if( h->dbgLevel )
fpga_load.c:1156:	if( (error = h->flash_entry.EraseSectors( &h->flashDev, startOffset,
fpga_load.c:1158:		return( -error );
fpga_load.c:1159:	else if( h->dbgLevel )
fpga_load.c:1160:		printf("  ----> OK\n\n");
fpga_load.c:1163:	h->flash_entry.Reset(&h->flashDev);
fpga_load.c:1165:	if( h->dbgLevel )
fpga_load.c:1167:	h->flash_entry.WriteBlock(&h->flashDev, startOffset, fileSize, fBuf );
fpga_load.c:1176:	h->flash_entry.Reset(&h->flashDev);
fpga_load.c:1184:		h->flash_entry.Exit(&h->flashDev);
fpga_load.c:1208: * 					or error (-error)
fpga_load.c:1227:	if( h->dbgLevel )
fpga_load.c:1233:		printf("\n*** ERROR: option -x requires bus switch [1/2/3] (see \"fpga_load -h\")\n");
fpga_load.c:1239:		if( h->dbgLevel ) {
fpga_load.c:1247:		if( h->dbgLevel ) {
fpga_load.c:1255:		if( h->dbgLevel ) {
fpga_load.c:1265:	if( (error = FindFlashSect( &h->flashDev,
fpga_load.c:1285:	h->flash_entry.ReadBlock(&h->flashDev, sectAddr, sectSize, buf);
fpga_load.c:1291:	if( h->dbgLevel )
fpga_load.c:1296:	if( (error = h->flash_entry.EraseSectors( &h->flashDev, sectAddr,
fpga_load.c:1299:	else if( h->dbgLevel )
fpga_load.c:1300:		printf("  ----> OK\n\n");
fpga_load.c:1303:	h->flash_entry.Reset(&h->flashDev);
fpga_load.c:1304:	if( h->dbgLevel )
fpga_load.c:1306:	h->flash_entry.WriteBlock(&h->flashDev, sectAddr, sectSize, buf );
fpga_load.c:1309:	h->flash_entry.Reset(&h->flashDev);
fpga_load.c:1318:	h->flash_entry.Reset(&h->flashDev);
fpga_load.c:1323:		h->flash_entry.Reset(&h->flashDev);
fpga_load.c:1338: *  \param flashInterf	\IN		0 - Z045_FLASH, 1 - PLD/SMB
fpga_load.c:1352:	if(h->dbgLevel)
fpga_load.c:1360:		if( h->mapType == OSS_ADDRSPACE_IO ){
fpga_load.c:1361:			h->mappedAddr = (u_int8*)h->physAddr;
fpga_load.c:1368:								 h->physAddr,
fpga_load.c:1370:								 h->mapType,
fpga_load.c:1371:								 h->busType,
fpga_load.c:1372:								 h->pciDev.bus,
fpga_load.c:1373:								 (void**)&h->mappedAddr)) )
fpga_load.c:1376:						(unsigned int)h->physAddr, (int)error);
fpga_load.c:1384:		h->mappedSize = MAP_REG_SIZE;
fpga_load.c:1385:		h->smbLocHdl.smbHdl = NULL;
fpga_load.c:1390:		if( !h->smbLocHdl.smbHdl ) {
fpga_load.c:1394:		h->flash_acc_size = Z100_FLASH_ACCESS_16BIT;
fpga_load.c:1401:	     if(h->interfacespi){
fpga_load.c:1405:                if( ((*Flash_try)(h, &Flash_init, h->dbgLevel)) == 0){
fpga_load.c:1413:        		if( ((*Flash_try)(h, &Flash_init, h->dbgLevel)) == 0){
fpga_load.c:1438: *  \return			file size or error (-1)
fpga_load.c:1453:	/*----------------------------------+
fpga_load.c:1455:	+----------------------------------*/
fpga_load.c:1459:		return( -1 );
fpga_load.c:1470:		error = -1;
fpga_load.c:1476:		error = -1;
fpga_load.c:1486:	if ( error == -1 )
fpga_load.c:1499: *  \return			success (0) or error (-1)
fpga_load.c:1506:	/*----------------------------------+
fpga_load.c:1508:	+----------------------------------*/
fpga_load.c:1512:		return(-1);
fpga_load.c:1517:		return(-1);
fpga_load.c:1536: * \return 0 on success or -1 if failed
fpga_load.c:1565:		/*------------------------------+
fpga_load.c:1567:		+------------------------------*/
fpga_load.c:1590:		/* try non-swapped and swapped */
fpga_load.c:1609:		/*------------------------------+
fpga_load.c:1611:		+------------------------------*/
fpga_load.c:1621:						 OSS_MERGE_BUS_DOMAIN(pciDev->bus, pciDomain),		/* pciBus */
fpga_load.c:1622:						 pciDev->dev,		/* pciDev */
fpga_load.c:1623:						 pciDev->fun,		/* pciFunc*/
fpga_load.c:1629:						 OSS_MERGE_BUS_DOMAIN(pciDev->bus, pciDomain),	/* pciBus */
fpga_load.c:1630:						 pciDev->dev,	/* pciDev */
fpga_load.c:1631:				 		 pciDev->fun,	/* pciFunc*/
fpga_load.c:1638:						 OSS_MERGE_BUS_DOMAIN(pciDev->bus, pciDomain),	/* pciBus */
fpga_load.c:1639:						 pciDev->dev,	/* pciDev */
fpga_load.c:1640:						 pciDev->fun,	/* pciFunc*/
fpga_load.c:1646:				OSS_MERGE_BUS_DOMAIN(pciDev->bus, pciDomain),	/* pciBus */
fpga_load.c:1647:				pciDev->dev,	/* pciDev */
fpga_load.c:1648:				pciDev->fun,	/* pciFunc*/
fpga_load.c:1658:					(int)pciDev->bus, (int)pciDev->dev, (int)pciDev->fun, (unsigned int)ret);
fpga_load.c:1663:	/*------------------------------+
fpga_load.c:1664:	|  CHAM - Info                  |
fpga_load.c:1665:	+------------------------------*/
fpga_load.c:1666:	if( chaFktTbl->Info( chaHdl, chamInfo ) != 0 )	{
fpga_load.c:1676:					pciDev->bus, pciDev->dev, pciDev->fun);
fpga_load.c:1690:				pciDev->bus, pciDev->dev, pciDev->fun);
fpga_load.c:1695:					(int)i, (int)chamInfo->ba[i].addr,
fpga_load.c:1696:					(int)chamInfo->ba[i].size,
fpga_load.c:1697:					chamInfo->ba[i].type == 0 ? "MEM" :
fpga_load.c:1698:					chamInfo->ba[i].type == 1 ? "IO" : "unused");
fpga_load.c:1701:	/*------------------------------+
fpga_load.c:1702:	|  CHAM - TableIdent            |
fpga_load.c:1703:	+------------------------------*/
fpga_load.c:1705:		if( (ret = chaFktTbl->TableIdent( chaHdl, i, &chamTable )) ==
fpga_load.c:1719:						pciDev->bus, pciDev->dev, pciDev->fun);
fpga_load.c:1739:			printf("gateware-revision: %d.%d\n", chamTable.revision, chamTable.minRevision);
fpga_load.c:1740:			printf("fpga-model: %c\n", chamTable.model);
fpga_load.c:1741:			printf("fpga-file: %s\n", tblfile);
fpga_load.c:1742:			printf("magic-word: 0x%04x\n", chamTable.magicWord);
fpga_load.c:1747:	/*------------------------------+
fpga_load.c:1748:	|  CHAM - UnitIdent             |
fpga_load.c:1749:	+------------------------------*/
fpga_load.c:1753:				"--- ------ ------------------------ --- ---- --- --- --- --- ---------- ----------\n");
fpga_load.c:1758:		if( (ret = chaFktTbl->UnitIdent( chaHdl, i, chamUnit )) ==
fpga_load.c:1772:						pciDev->bus, pciDev->dev, pciDev->fun);
fpga_load.c:1778:			printf("%3d 0x%04x %-24s %3d %4d %3d %3d %3d %3d 0x%08lx %p\n",
fpga_load.c:1779:				   (int)i, chamUnit->devId,CHAM_DevIdToName(chamUnit->devId),chamUnit->group,
fpga_load.c:1780:				   chamUnit->instance, chamUnit->variant, chamUnit->revision,
fpga_load.c:1781:				   (chamUnit->interrupt /*- SYS_NUM_CHAM_INTO*/), chamUnit->bar,
fpga_load.c:1782:				   chamUnit->offset, chamUnit->addr);
fpga_load.c:1786:		if( ((chamInfo->chaRev <  2) && (chamUnit->devId == mod_id))    ||
fpga_load.c:1787:			((chamInfo->chaRev >= 2) && (chamUnit->devId == mod_id) &&
fpga_load.c:1788:			 (chamUnit->group == mod_group)) )
fpga_load.c:1797:		if ( chamUnit->devId == CHAMELEON_16Z126_SERFLASH )
fpga_load.c:1802:			        pRegs = (char *)mmap( NULL, pgsz, PROT_READ | PROT_WRITE, MAP_SHARED, fd, (long)(chamUnit->addr) & ~(pgsz-1));
fpga_load.c:1803:			        if (pRegs == (void *)-1 ) {
fpga_load.c:1807:			        	z126Status = ((u_int32*)pRegs)[ (chamUnit->offset + SFII_BSR) >> 2 ];
fpga_load.c:1816:	/* from 16Z126-01_IcArchSpec.doc table 31:
fpga_load.c:1824:			printf("image-type: ");
fpga_load.c:1827:					printf ("fallback no-config-error\n" );
fpga_load.c:1833:					printf ("fallback config-error\n" );
fpga_load.c:1862:	if ( !(flags & (CF_ALL_TABLES|CF_VERSION)) && ( chamUnit->devId != mod_id ) ){
fpga_load.c:1867:		chaFktTbl->UnitIdent( chaHdl, chaUnitNbr, chamUnit );
fpga_load.c:1870:	chaFktTbl->Term( &chaHdl );
fpga_load.c:1879:		chaFktTbl->Term( &chaHdl );
fpga_load.c:1888: *---------------------------------------------------------------------------
fpga_load.c:1894: *  \return	sector number or error (-1) if not found
fpga_load.c:1904:	for( sect=0; sect < fDev->nSectors; sect++ ){
fpga_load.c:1905:		if( addr >= fDev->sectAddr[sect]*2 &&
fpga_load.c:1906:			addr < fDev->sectAddr[sect+1]*2){
fpga_load.c:1907:			*sectAddr = fDev->sectAddr[sect]*2;
fpga_load.c:1908:			*sectSize = (fDev->sectAddr[sect+1] - fDev->sectAddr[sect])*2;
fpga_load.c:1912:	return -1;
fpga_load.c:1929:	fDev->devHdl->flash_entry.ReadBlock( fDev,
fpga_load.c:1935:	if( fDev->devHdl->dbgLevel )
fpga_load.c:1941:				(unsigned int)Z100_SWAP_BE32(header->magic),
fpga_load.c:1942:				header->boardType,
fpga_load.c:1943:				(unsigned int)Z100_SWAP_BE32(header->offset[0]),
fpga_load.c:1944:				(unsigned int)Z100_SWAP_BE32(header->offset[1]),
fpga_load.c:1945:				(unsigned int)Z100_SWAP_BE32(header->offset[2]),
fpga_load.c:1946:				(unsigned int)Z100_SWAP_BE32(header->offset[3]) );
fpga_load.c:1974:	h->flash_entry.Reset(&h->flashDev);
fpga_load.c:1977:	if( h->dbgLevel )
fpga_load.c:1989:	h->flash_entry.ReadBlock(&h->flashDev, offset, len, verBuf);
fpga_load.c:2034:					(int)n, (int)pciDomain, (int)pciDevs[n]->bus, (int)pciDevs[n]->dev, (int)pciDevs[n]->fun,
fpga_load.c:2035:					(unsigned int)pciDevs[n]->venId,
fpga_load.c:2036:					(unsigned int)pciDevs[n]->devId,
fpga_load.c:2037:					(unsigned int)pciDevs[n]->subSysVenId);
fpga_load.c:2046:					(int)n, pciDevs[n]->bus, pciDevs[n]->dev, pciDevs[n]->fun,
fpga_load.c:2047:					(unsigned int)pciDevs[n]->bar[0],
fpga_load.c:2048:					(unsigned int)pciDevs[n]->bar[1],
fpga_load.c:2049:					(unsigned int)pciDevs[n]->bar[2],
fpga_load.c:2050:					(unsigned int)pciDevs[n]->bar[3],
fpga_load.c:2051:					(unsigned int)pciDevs[n]->bar[4],
fpga_load.c:2052:					(unsigned int)pciDevs[n]->bar[5]);
fpga_load.c:2066: *  \return success (0) or error (-1)
fpga_load.c:2076:	u_int32 vendorId=dev->venId,
fpga_load.c:2077:			deviceId=dev->devId,
fpga_load.c:2078:			subSysVenId=dev->subSysVenId,
fpga_load.c:2102:				/* if PCI bus is not implemented, 0 is returned instead of -1 */
fpga_load.c:2118:					pCurdev->bus = (u_int8)bus;
fpga_load.c:2119:					pCurdev->dev = (u_int8)slot;
fpga_load.c:2120:					pCurdev->fun = (u_int8)function;
fpga_load.c:2122:					pCurdev->venId = val1;
fpga_load.c:2127:									  (int32 *)&pCurdev->devId);
fpga_load.c:2131:									  (int32 *)&pCurdev->subSysVenId);
fpga_load.c:2137:					pCurdev->origComReg = (u_int16)(Z100_SWAP_BE16(comReg));
fpga_load.c:2149:									(int32 *)&pCurdev->bar[barn]);
fpga_load.c:2150:					pCurdev->comRegChanged = 0;
fpga_load.c:2156:						(pCurdev->venId == vendorId) &&
fpga_load.c:2157:						(pCurdev->devId == deviceId) &&
fpga_load.c:2158:						(pCurdev->subSysVenId == subSysVenId) )
fpga_load.c:2162:						if( !(pCurdev->origComReg &
fpga_load.c:2164:							!(pCurdev->origComReg &
fpga_load.c:2167:							pCurdev->comRegChanged = 1;
fpga_load.c:2169:                            dev->comRegChanged = 1;
fpga_load.c:2170:                            dev->origComReg = pCurdev->origComReg;
fpga_load.c:2175:											Z100_SWAP_BE16(pCurdev->origComReg    |
fpga_load.c:2202:								/* not a multi-function card */
fpga_load.c:2232:	return( -1 );
fpga_load.c:2264:	if( h->dbgLevel )
fpga_load.c:2268:		if( !strcmp( "-a", *argv ) ) {
fpga_load.c:2272:				printf("*** ERROR: option -a requires VME address as hex value\n"
fpga_load.c:2279:		argc--;
fpga_load.c:2308:	h->physAddr = vmeLocAddr;
fpga_load.c:2309:	h->busType  = OSS_BUSTYPE_VME;
fpga_load.c:2310:	h->mapType  = OSS_ADDRSPACE_MEM;
fpga_load.c:2373:										 * accesses to PCI IO-mapped devs */
fpga_load.c:2376:	if( h->dbgLevel )
fpga_load.c:2383:		printf("*** ERROR: option -b requires option -o as well\n"
fpga_load.c:2392:	showChamFlags |= (h->dbgLevel     ? CF_DEBUG : 0);
fpga_load.c:2395:	pciDev = &h->pciDev;
fpga_load.c:2400:		    !sscanf(argv[1], "%x", (unsigned int*)&pciDev->venId) ||
fpga_load.c:2401:		    !sscanf(argv[2], "%x", (unsigned int*)&pciDev->devId) ||
fpga_load.c:2402:		    !sscanf(argv[3], "%x", (unsigned int*)&pciDev->subSysVenId) ||
fpga_load.c:2406:		    !sscanf(argv[1], "%x", (unsigned int*)&pciDev->venId) ||
fpga_load.c:2407:		    !sscanf(argv[2], "%x", (unsigned int*)&pciDev->devId) ||
fpga_load.c:2408:		    !sscanf(argv[3], "%x", (unsigned int*)&pciDev->subSysVenId) ||
fpga_load.c:2434:	if( showOnly && !(pciDev->venId && pciDev->devId && pciDev->subSysVenId) ) {
fpga_load.c:2454:	if( instance > (numDevs - 1) ) {
fpga_load.c:2463:	if( h->dbgLevel ) {
fpga_load.c:2468:	h->busType = OSS_BUSTYPE_PCI;
fpga_load.c:2478:			if( !strcmp( "-m", *largv ) ) {
fpga_load.c:2482:					printf("*** ERROR: option -m requires offset as hex value\n"
fpga_load.c:2487:				largc -= 2;
fpga_load.c:2491:			if( !strcmp( "-i", *largv ) ) {
fpga_load.c:2495:					printf("*** ERROR: option -i requires offset as hex value\n"
fpga_load.c:2500:				largc -= 2;
fpga_load.c:2504:			largc--;
fpga_load.c:2509:			if( pciDev->bar[i] & 0x00000001 )
fpga_load.c:2510:				/* bar is IO-mapped */
fpga_load.c:2511:				pciDev->bar[i] += cpu_to_pci_io_offset;
fpga_load.c:2514:				pciDev->bar[i] += cpu_to_pci_mem_offset;
fpga_load.c:2522:		if( h->pciDev.bar[barN] & 0x1 ) {
fpga_load.c:2524:			h->chamInfo.ba[barN].type = OSS_ADDRSPACE_IO;
fpga_load.c:2525:			if( h->dbgLevel )
fpga_load.c:2528:		h->chamUnit.bar = barN;
fpga_load.c:2529:		h->chamUnit.addr = (void*)((h->pciDev.bar[barN] & ~0x0f) +
fpga_load.c:2531:		h->physAddr = (void*)h->chamUnit.addr;
fpga_load.c:2532:		h->mapType = h->pciDev.bar[barN] & 0x01;
fpga_load.c:2539:        if (h->interfacespi == 1){
fpga_load.c:2545:			if( !strcmp(h->smbLocHdl.smbCtlName, "menz001") )
fpga_load.c:2560:		if( (error = Get_Chameleon( osHdl, &h->pciDev, NULL, modId, grpId,
fpga_load.c:2561:			&h->chamInfo, &h->chamUnit, showChamFlags, pciDomain)) )
fpga_load.c:2578:		if(h->chamInfo.ba[h->chamUnit.bar].type)
fpga_load.c:2580:			h->physAddr = (void*)h->chamUnit.addr + cpu_to_pci_io_offset;
fpga_load.c:2583:			h->physAddr = (void*)h->chamUnit.addr + cpu_to_pci_mem_offset;
fpga_load.c:2586:		h->physAddr = (void*)h->chamUnit.addr;
fpga_load.c:2588:		h->mapType = h->chamInfo.ba[h->chamUnit.bar].type;
fpga_load.c:2615:	if( h->pciDev.comRegChanged == 1 ) {
fpga_load.c:2617:				h->pciDev.bus, h->pciDev.dev, h->pciDev.fun,
fpga_load.c:2619:				Z100_SWAP_BE16(h->pciDev.origComReg ))))
fpga_load.c:2655:	if( h->dbgLevel )
fpga_load.c:2660:	showChamFlags |= (h->dbgLevel     ? CF_DEBUG : 0);
fpga_load.c:2670:    if (h->interfacespi == 1){
fpga_load.c:2676:		if( !strcmp(h->smbLocHdl.smbCtlName, "menz001") )
fpga_load.c:2692:		&h->chamInfo, &h->chamUnit, showChamFlags, 0)) )
fpga_load.c:2706:	h->physAddr = (void*)h->chamUnit.addr;
fpga_load.c:2707:	h->mapType = h->chamInfo.ba[h->chamUnit.bar].type;
fpga_load.c:2740:	if( h->dbgLevel )
fpga_load.c:2744:	if( !strcmp(h->smbLocHdl.smbCtlName, "menz001") )
fpga_load.c:2747:						 h->physAddr,
fpga_load.c:2749:						 h->mapType,
fpga_load.c:2750:						 h->busType,
fpga_load.c:2751:						 h->pciDev.bus,
fpga_load.c:2752:						 (void**)&h->mappedAddr)) )
fpga_load.c:2755:					h->physAddr, (int)error);
fpga_load.c:2758:		h->mappedSize = MAP_REG_SIZE;
fpga_load.c:2760:		z001_desc.baseAddr		= (void*) h->mappedAddr;
fpga_load.c:2768:		if( (error = SMB_MENZ001_Init( &z001_desc, osHdl, &h->smbLocHdl.smbHdl )) )
fpga_load.c:2781:							h->smbLocHdl.smbCtlNum,
fpga_load.c:2782:							&h->smbLocHdl.smbHdl);
fpga_load.c:2786:		h->smbLocHdl.smbHdl = NULL;
fpga_load.c:2817:	SMB_HANDLE *smbHdl = (SMB_HANDLE*)h->smbLocHdl.smbHdl;
fpga_load.c:2819:	if( h->dbgLevel )
fpga_load.c:2823:	if( *h->smbLocHdl.smbCtlName && (error = smbHdl->Exit(&h->smbLocHdl.smbHdl)) )
program_sw.mak:9:#---------------------------------[ History ]---------------------------------
program_sw.mak:38:#-----------------------------------------------------------------------------
stm25p32.c:1:/*********************  P r o g r a m  -  M o d u l e ***********************/
stm25p32.c:12: *     Required: -
stm25p32.c:15: /*---------------------------[ Public Functions ]----------------------------
stm25p32.c:19: *---------------------------------------------------------------------------
stm25p32.c:40:/*--------------------------------------+
stm25p32.c:42:+--------------------------------------*/
stm25p32.c:55:/*--- bit fields for the commands at address lines > bitnbr 24  ---*/
stm25p32.c:56:/*--- for the altasmi_parallel Megafunctions ---*/
stm25p32.c:70:/*--- known manufacturer codes/device codes ---*/
stm25p32.c:79:/*--------------------------------------+
stm25p32.c:81:+--------------------------------------*/
stm25p32.c:84:/*--------------------------------------+
stm25p32.c:86:+--------------------------------------*/
stm25p32.c:89:/*--------------------------------------+
stm25p32.c:91:+--------------------------------------*/
stm25p32.c:116:/*--------------------------------------+
stm25p32.c:118:+--------------------------------------*/
stm25p32.c:265: *-----------------------------------------------------------------------------
stm25p32.c:281:	if(devHdl->mapType){
stm25p32.c:282:		if(devHdl->interfacemmod){
stm25p32.c:287:			devHdl->Mread_D8   = Z100_Mread_Io_D8_Sw;
stm25p32.c:288:			devHdl->Mread_D16  = Z100_Mread_Io_D16_Sw;
stm25p32.c:289:			devHdl->Mread_D32  = Z100_Mread_Io_D32_Sw;
stm25p32.c:290:			devHdl->Mwrite_D8  = Z100_Mwrite_Io_D8_Sw;
stm25p32.c:291:			devHdl->Mwrite_D16 = Z100_Mwrite_Io_D16_Sw;
stm25p32.c:292:			devHdl->Mwrite_D32 = Z100_Mwrite_Io_D32_Sw;
stm25p32.c:294:			devHdl->Mread_D8   = Z100_Mread_Io_D8;
stm25p32.c:295:			devHdl->Mread_D16  = Z100_Mread_Io_D16;
stm25p32.c:296:			devHdl->Mread_D32  = Z100_Mread_Io_D32;
stm25p32.c:297:			devHdl->Mwrite_D8  = Z100_Mwrite_Io_D8;
stm25p32.c:298:			devHdl->Mwrite_D16 = Z100_Mwrite_Io_D16;
stm25p32.c:299:			devHdl->Mwrite_D32 = Z100_Mwrite_Io_D32;
stm25p32.c:308:		/*--- get read / write function pointer ---*/
stm25p32.c:309:		if(devHdl->interfacemmod){
stm25p32.c:310:			devHdl->Mread_D8   = MMOD_Mread_Mem_D8;
stm25p32.c:311:			devHdl->Mread_D16  = MMOD_Mread_Mem_D16;
stm25p32.c:312:			devHdl->Mread_D32  = MMOD_Mread_Mem_D32;
stm25p32.c:313:			devHdl->Mwrite_D8  = MMOD_Mwrite_Mem_D8;
stm25p32.c:314:			devHdl->Mwrite_D16 = MMOD_Mwrite_Mem_D16;
stm25p32.c:315:			devHdl->Mwrite_D32 = MMOD_Mwrite_Mem_D32;
stm25p32.c:317:			devHdl->Mread_D8   = Z100_Mread_Mem_D8;
stm25p32.c:318:			devHdl->Mread_D16  = Z100_Mread_Mem_D16;
stm25p32.c:319:			devHdl->Mread_D32  = Z100_Mread_Mem_D32;
stm25p32.c:320:			devHdl->Mwrite_D8  = Z100_Mwrite_Mem_D8;
stm25p32.c:321:			devHdl->Mwrite_D16 = Z100_Mwrite_Mem_D16;
stm25p32.c:322:			devHdl->Mwrite_D32 = Z100_Mwrite_Mem_D32;
stm25p32.c:328:	if(devHdl->interfacemmod){
stm25p32.c:329:		devHdl->Read  = Z100_Flash_Read;
stm25p32.c:330:		devHdl->Write = Z100_Flash_Write;
stm25p32.c:332:		devHdl->Read  = MMOD_Flash_Read;
stm25p32.c:333:		devHdl->Write = MMOD_Flash_Write;
stm25p32.c:345:			(int)devHdl->flashDev.manId, (int)devHdl->flashDev.devId,
stm25p32.c:346:			(int)devHdl->flashDev.sectSize, (int)devHdl->flashDev.nSectors,
stm25p32.c:347:			(int)devHdl->flashDev.bootSect));
stm25p32.c:362:/*----------------------------------------------------------------------
stm25p32.c:364: *---------------------------------------------------------------------*/
stm25p32.c:371: *-----------------------------------------------------------------------------
stm25p32.c:378:	FLASH_ENTRY *ent = &h->flash_entry;
stm25p32.c:380:	ent->Exit 			= &Exit;
stm25p32.c:381:	ent->Reset 			= &Reset;
stm25p32.c:382:	ent->ReadBlock 		= &ReadBlock;
stm25p32.c:383:	ent->WriteBlock		= &WriteBlock;
stm25p32.c:384:	ent->EraseChip  	= &EraseChip;
stm25p32.c:385:	ent->EraseSectors	= &EraseSectors;
stm25p32.c:386:	h->flashDev.isInit	= TRUE;
stm25p32.c:388:	Reset(&h->flashDev);		/* reset device to read mode */
stm25p32.c:398: *-----------------------------------------------------------------------------
stm25p32.c:408:	fDev->devHdl->flashDev.isInit = FALSE;
stm25p32.c:417: *-----------------------------------------------------------------------------
stm25p32.c:429:	devHdl->flash_acc_size = Z100_FLASH_ACCESS_8BIT;		/* 8 bit Flash */
stm25p32.c:436:		devHdl->flashDev.manId = retval & 0xff;
stm25p32.c:437:        devHdl->flashDev.devId = DEVCODE_M25P32;
stm25p32.c:440:	if( devHdl->dbgLevel )
stm25p32.c:442:				(unsigned int)devHdl->flashDev.manId,
stm25p32.c:443:				(int)devHdl->flashDev.devId);
stm25p32.c:450: * ---------------------------------------------------------------------------
stm25p32.c:453: *  Globals....: -
stm25p32.c:458:			(unsigned int)devHdl->flashDev.manId,
stm25p32.c:459:			(int)devHdl->flashDev.devId) );
stm25p32.c:461:	/*--- check if device is supported ---*/
stm25p32.c:462:	if( (devHdl->flashDev.manId == MANUFACT_STMICRO) 	 ||
stm25p32.c:463:	    (devHdl->flashDev.manId == MANUFACT_STMICRO_64 ) ||
stm25p32.c:464:		(devHdl->flashDev.manId == MANUFACT_STMICRO_128))
stm25p32.c:469:		while( d->devId ){
stm25p32.c:470:			if( ( devHdl->flashDev.devId == d->devId ) &&
stm25p32.c:471:			 	( devHdl->flashDev.manId == d->manId) )
stm25p32.c:473:				if(devHdl->dbgLevel)
stm25p32.c:475:						 "    Found FLASH device %s\n", d->name );
stm25p32.c:477:				devHdl->flashDev.sectSize = d->sectSize;
stm25p32.c:478:				devHdl->flashDev.nSectors = d->nSectors;
stm25p32.c:479:				devHdl->flashDev.bootSect = d->bootSect;
stm25p32.c:481:					devHdl->flashDev.sectAddr[i] = d->sectAddr[i];
stm25p32.c:482:				devHdl->flashDev.devHdl   = devHdl;
stm25p32.c:483:				devHdl->flashDev.isInit  = 0;
stm25p32.c:496: *-----------------------------------------------------------------------------
stm25p32.c:503:    DEV_HDL *h = fDev->devHdl;
stm25p32.c:508:    Z100_FLASH_WRITE( fDev->devHdl, BIT_BULKERASE , 0 );
stm25p32.c:510:    error = DataPollingAlg(fDev->devHdl, 0, 0, 80000);
stm25p32.c:519: *---------------------------------------------------------------------------
stm25p32.c:530:	DEV_HDL *h = fDev->devHdl;
stm25p32.c:534:		/*--- check start address ---*/
stm25p32.c:535:	if(startOffs >= fDev->sectAddr[fDev->nSectors]*2){
stm25p32.c:540:	/*--- limit to device size ---*/
stm25p32.c:541:	if( (startOffs + len) >= fDev->sectAddr[fDev->nSectors]*2 )
stm25p32.c:542:		len = fDev->sectAddr[fDev->nSectors]*2 - startOffs - 1;
stm25p32.c:545:	phyEnd   = startOffs + len -1;
stm25p32.c:547:	/*--- convert to sector boundaries ---*/
stm25p32.c:549:	phyStart &= ~(sectSize-1);
stm25p32.c:552:	phyEnd &= ~(sectSize-1);
stm25p32.c:560:	/*--- read sector protect bits ---*/
stm25p32.c:563:	    /*--- Unlock the protected areas ---*/
stm25p32.c:570:		if( fDev->devHdl->dbgLevel )
stm25p32.c:572:					(int)sect+1, (int)fDev->nSectors, (unsigned int)sectSize);
stm25p32.c:574:        /*--- set BIT_SECTORERASE and address ---*/
stm25p32.c:575:		Z100_FLASH_WRITE( fDev->devHdl, BIT_SECTORERASE | (phyStart & 0xFFFFFF), 0);
stm25p32.c:577:        error = DataPollingAlg(fDev->devHdl, 0, 0, 3000);
stm25p32.c:581:		if( fDev->devHdl->dbgLevel )
stm25p32.c:582:			printf("    Erase Sector ----> OK\n");
stm25p32.c:597: *-----------------------------------------------------------------------------
stm25p32.c:616:	DEV_HDL *h		= fDev->devHdl;
stm25p32.c:626:    if( ( offs >= fDev->sectAddr[fDev->nSectors]*2) ||
stm25p32.c:627:        ((offs + len) > fDev->sectAddr[fDev->nSectors]*2))
stm25p32.c:634:	/*--- read sector protect bits ---*/
stm25p32.c:637:	    /*--- Unlock the protected areas ---*/
stm25p32.c:643:	blockdif = 256 - (startoffs & 0xff);
stm25p32.c:646:		/*--- write 8 bit to the data register ---*/
stm25p32.c:647:		Z100_MWRITE_D8( h->mappedAddr, Z045_FLASH_DATA_REG_OFFSET, (u_int8)0xff);
stm25p32.c:649:	/*--- start address is no 256 byte block address ---*/
stm25p32.c:652:		/*--- write 8 bit to the data register ---*/
stm25p32.c:653:		Z100_MWRITE_D8( h->mappedAddr, Z045_FLASH_DATA_REG_OFFSET, (u_int8)(val & 0xff));
stm25p32.c:654:		len--;
stm25p32.c:657:		/*--- write the address register and the write bit ---*/
stm25p32.c:658:		Z100_MWRITE_D32( h->mappedAddr, Z045_FLASH_ADDR_REG_OFFSET, BIT_WRITE | (offs & 0xFFFFFF));
stm25p32.c:659:		/*--- wait for reset of data busy ---*/
stm25p32.c:672:	/*--- calculate the number of 32 bit accesses til the end of the file ---*/
stm25p32.c:679:        if( !(i % 32768 )&& ( i != 0 ) && h->dbgLevel) /* write status all 128KB */
stm25p32.c:683:			/*--- write the address register and the write bit every 256 bytes ---*/
stm25p32.c:684:			Z100_MWRITE_D32( h->mappedAddr, Z045_FLASH_ADDR_REG_OFFSET, BIT_WRITE | (offs & 0xFFFFFF));
stm25p32.c:685:			/*--- wait for reset of data busy ---*/
stm25p32.c:693:		if(i == nWrite-1){
stm25p32.c:697:				/*--- write 32 bit to the data register ---*/
stm25p32.c:698:    			Z100_MWRITE_D32( h->mappedAddr, Z045_FLASH_DATA_REG_OFFSET, SW32(val) );
stm25p32.c:701:				/*--- write 8 bit to the data register ---*/
stm25p32.c:702:    			Z100_MWRITE_D8( h->mappedAddr, Z045_FLASH_DATA_REG_OFFSET,(u_int8)(SW32(val) & 0xff) );
stm25p32.c:705:				/*--- write 16 bit to the data register ---*/
stm25p32.c:706:    			Z100_MWRITE_D16( h->mappedAddr, Z045_FLASH_DATA_REG_OFFSET, (u_int16)(SW32(val) & 0xffff) );
stm25p32.c:709:				/*--- write 16 bit to the data register ---*/
stm25p32.c:710:    			Z100_MWRITE_D16( h->mappedAddr, Z045_FLASH_DATA_REG_OFFSET, (u_int16)(SW32(val) & 0xffff) );
stm25p32.c:711:				/*--- write 8 bit to the data register offset + 2 ---*/
stm25p32.c:712:				Z100_MWRITE_D8( h->mappedAddr, Z045_FLASH_DATA_REG_OFFSET + 2,
stm25p32.c:718:			/*--- write 32 bit to the data register ---*/
stm25p32.c:719:    		Z100_MWRITE_D32( h->mappedAddr, Z045_FLASH_DATA_REG_OFFSET, SW32(val));
stm25p32.c:722:	if (len != 0){	/* len < 256 is already written -> len = 0 */
stm25p32.c:723:		/*--- write the address register and the write bit every 256 bytes ---*/
stm25p32.c:724:		Z100_MWRITE_D32( h->mappedAddr, Z045_FLASH_ADDR_REG_OFFSET, BIT_WRITE | (offs & 0xFFFFFF));
stm25p32.c:725:		/*--- write data register dummy 0xa5a5a5a5 to enable bit write ---*/
stm25p32.c:726:/* TODO: Added for testing with the SPI Flash		Z100_MWRITE_D32( h->mappedAddr, Z045_FLASH_DATA_REG_OFFSET, 0xa5a5a5a5); */
stm25p32.c:727:		/*--- wait for reset of data busy ---*/
stm25p32.c:745: *-----------------------------------------------------------------------------
stm25p32.c:765:	DEV_HDL *h = fDev->devHdl;
stm25p32.c:773:	/*--- calculate number of 32 bit accesses ---*/
stm25p32.c:777:	/*--- add one nAccess to a next 32 bit area ---*/
stm25p32.c:783:	/*--- write the address to read from  ---*/
stm25p32.c:784:    Z100_MWRITE_D32( h->mappedAddr, Z045_FLASH_ADDR_REG_OFFSET, offset & 0xFFFFFC);
stm25p32.c:789:		   /*--- read 32 bit data from the data register ---*/
stm25p32.c:790:		   retVal = Z100_MREAD_D32(h->mappedAddr, Z045_FLASH_DATA_REG_OFFSET);
stm25p32.c:795:			/*--- read 8 bit data from the data register ---*/
stm25p32.c:796:			retVal8 = Z100_MREAD_D8(h->mappedAddr, Z045_FLASH_DATA_REG_OFFSET+3);
stm25p32.c:802:			/*--- read 16 bit data from the data register ---*/
stm25p32.c:803:			retVal16 = Z100_MREAD_D16(h->mappedAddr, Z045_FLASH_DATA_REG_OFFSET+2);
stm25p32.c:809:			/*--- read 32 bit data from the data register ---*/
stm25p32.c:810:			retVal = Z100_MREAD_D32(h->mappedAddr, Z045_FLASH_DATA_REG_OFFSET);
stm25p32.c:819:        len -= (4 - (offset % 4));
stm25p32.c:820:	offset -= offset % 4 ;
stm25p32.c:822:	nAccess--;
stm25p32.c:826:            /*--- write the address to read from  ---*/
stm25p32.c:827:            Z100_MWRITE_D32( h->mappedAddr, Z045_FLASH_ADDR_REG_OFFSET, offset & 0xFFFFFC);
stm25p32.c:828:            /*--- read 8 bit data from the data register ---*/
stm25p32.c:829:			retVal8 = Z100_MREAD_D8(h->mappedAddr, Z045_FLASH_DATA_REG_OFFSET+(offset%4));
stm25p32.c:840:        Z100_MWRITE_D32( h->mappedAddr, Z045_FLASH_ADDR_REG_OFFSET, offset & 0xFFFFFF);
stm25p32.c:844:			   /*--- read 32 bit data from the data register ---*/
stm25p32.c:845:			   retVal = Z100_MREAD_D32(h->mappedAddr, Z045_FLASH_DATA_REG_OFFSET);
stm25p32.c:853:                /*--- read 8 bit data from the data register ---*/
stm25p32.c:854:                retVal8 = Z100_MREAD_D8(h->mappedAddr, Z045_FLASH_DATA_REG_OFFSET);
stm25p32.c:862:                /*--- read 16 bit data from the data register ---*/
stm25p32.c:863:                retVal16 = Z100_MREAD_D16(h->mappedAddr, Z045_FLASH_DATA_REG_OFFSET);
stm25p32.c:872:                /*--- read 32 bit data from the data register ---*/
stm25p32.c:873:                retVal = Z100_MREAD_D32(h->mappedAddr, Z045_FLASH_DATA_REG_OFFSET);
stm25p32.c:886:            /*--- read 32 bit data from the data register ---*/
stm25p32.c:887:            retVal = Z100_MREAD_D32(h->mappedAddr, Z045_FLASH_DATA_REG_OFFSET);
stm25p32.c:894:		nAccess--;
stm25p32.c:904: *---------------------------------------------------------------------------
stm25p32.c:909:	DEV_HDL *h = fDev->devHdl;
stm25p32.c:911:	Z100_FLASH_WRITE( fDev->devHdl,0,0);
stm25p32.c:918: *-----------------------------------------------------------------------------
stm25p32.c:936:    if ((h->flashDev.manId == MANUFACT_STMICRO_64) || (h->flashDev.manId == MANUFACT_STMICRO_128))
stm25p32.c:946:        retVal = Z100_MREAD_D32 (h->mappedAddr,Z045_FLASH_ADDR_REG_OFFSET);
stm25p32.c:948:		/*--- check the busy flag  ---*/
stm25p32.c:950:		    if((retVal & BIT_ILLERASE )) /*--- illegal erase active ---*/
stm25p32.c:958:		    if((retVal & BIT_ILLWRITE )) /*--- illegal write active ---*/
stm25p32.c:965:		if(!(retVal & BIT_BUSY ) )  /*--- busy flag not active ---*/
stm25p32.c:979:	    /*--- read the status ---*/
stm25p32.c:981:		    SW32((unsigned int)Z100_MREAD_D32( h->mappedAddr ,Z045_FLASH_DATA_REG_OFFSET )) ));
stm25p32.c:989: *-----------------------------------------------------------------------------
stm25p32.c:994: *  \return	sector number or error (-1) if not found
stm25p32.c:1001:	addr &= (fDev->sectAddr[fDev->nSectors]*2 - 1);
stm25p32.c:1003:	for( sect=0; sect < fDev->nSectors; sect++ ){
stm25p32.c:1004:		if( (addr >= fDev->sectAddr[sect]*2) && (addr < fDev->sectAddr[sect+1]*2))
stm25p32.c:1006:			*phySizeP = (fDev->sectAddr[sect+1] - fDev->sectAddr[sect])*2;
stm25p32.c:1007:			/* printf("FindSect: addr = %x -> sect = %d *phySizeP = %x \n", addr, sect, *phySizeP ); */
stm25p32.c:1012:	return -1;
stm25p32.c:1019: *-----------------------------------------------------------------------------
stm25p32.c:1026:	DEV_HDL *h = fDev->devHdl;
stm25p32.c:1029:	if( h->dbgLevel )
stm25p32.c:1032:	/*--- give UNLOCK BLOCK command ---*/
stm25p32.c:1033:	Z100_FLASH_WRITE( fDev->devHdl, BIT_SECTORPROTECT, 0  );
stm25p32.c:1035:	error = DataPollingAlg(fDev->devHdl, 0, 0, 20);
_amd_smb_stub.c:1:/*********************  P r o g r a m  -  M o d u l e ***********************/
_amd_smb_stub.c:12: *     Required: -
_amd_smb_stub.c:15: /*---------------------------[ Public Functions ]----------------------------
_amd_smb_stub.c:18: *---------------------------------------------------------------------------
am29lvxxx_smb.c:1:/*********************  P r o g r a m  -  M o d u l e ***********************/
am29lvxxx_smb.c:14: *     Required: -
am29lvxxx_smb.c:17: /*---------------------------[ Public Functions ]----------------------------
am29lvxxx_smb.c:21: *---------------------------------------------------------------------------
am29lvxxx_smb.c:49:/*--------------------------------------+
am29lvxxx_smb.c:51:+--------------------------------------*/
am29lvxxx_smb.c:69:/*--- command codes ---*/
am29lvxxx_smb.c:78:/*--- known manufacturer codes/device codes ---*/
am29lvxxx_smb.c:93:/*--- erase states ---*/
am29lvxxx_smb.c:100:/*--------------------------------------+
am29lvxxx_smb.c:102:+--------------------------------------*/
am29lvxxx_smb.c:110:/*--------------------------------------+
am29lvxxx_smb.c:112:+--------------------------------------*/
am29lvxxx_smb.c:115:/*--------------------------------------+
am29lvxxx_smb.c:117:+--------------------------------------*/
am29lvxxx_smb.c:121:	{ "A404-", MANUFACT_AMD, DEVCODE_29LV160DT, DO_BIT_REVERSE },
am29lvxxx_smb.c:122:	{ "A500-", MANUFACT_AMD, DEVCODE_29LV160DT, DO_BIT_REVERSE },
am29lvxxx_smb.c:171:/*--------------------------------------+
am29lvxxx_smb.c:173:+--------------------------------------*/
am29lvxxx_smb.c:208: *---------------------------------------------------------------------------
am29lvxxx_smb.c:221:	SMB_HANDLE *smbHdl = (SMB_HANDLE*)devHdl->smbLocHdl.smbHdl;
am29lvxxx_smb.c:238:			(int)devHdl->flashDev.manId, (int)devHdl->flashDev.devId,
am29lvxxx_smb.c:239:			(int)devHdl->flashDev.sectSize, (int)devHdl->flashDev.nSectors,
am29lvxxx_smb.c:240:			(int)devHdl->flashDev.bootSect));
am29lvxxx_smb.c:261: *---------------------------------------------------------------------------
am29lvxxx_smb.c:268:	FLASH_ENTRY *ent = &h->flash_entry;
am29lvxxx_smb.c:270:	ent->Exit 		= &Exit;
am29lvxxx_smb.c:271:	ent->Reset 		= &Reset;
am29lvxxx_smb.c:272:	ent->ReadBlock 	= &ReadBlock;
am29lvxxx_smb.c:273:	ent->WriteBlock	= &WriteBlock;
am29lvxxx_smb.c:274:	ent->EraseChip  = &EraseChip;
am29lvxxx_smb.c:275:	ent->EraseSectors= &EraseSectors;
am29lvxxx_smb.c:276:	h->flashDev.isInit = TRUE;
am29lvxxx_smb.c:278:	Reset(&h->flashDev);				/* reset device to read mode */
am29lvxxx_smb.c:285: *---------------------------------------------------------------------------
am29lvxxx_smb.c:295:	fDev->devHdl->flashDev.isInit = FALSE;
am29lvxxx_smb.c:299:/*----------------------------------------------------------------------
am29lvxxx_smb.c:301: *---------------------------------------------------------------------*/
am29lvxxx_smb.c:307: *---------------------------------------------------------------------------
am29lvxxx_smb.c:317:	SMB_HANDLE *smbHdl = (SMB_HANDLE*)devHdl->smbLocHdl.smbHdl;
am29lvxxx_smb.c:323:	if( (error = smbHdl->ReadByteData( smbHdl, 0,
am29lvxxx_smb.c:337:		if( (error = smbHdl->ReadByte( smbHdl, 0,
am29lvxxx_smb.c:351:		hwName = &eeprod->pd_hwName[0];
am29lvxxx_smb.c:355:		hwName = &eeprod2->pd_hwName[0];
am29lvxxx_smb.c:365:    hwName = boardData->hwName; /* IDPROM CHECK disabled for the A404 */
am29lvxxx_smb.c:367:	while( boardData->devId )
am29lvxxx_smb.c:370:				boardData->hwName));
am29lvxxx_smb.c:371:		if( !strncmp(hwName, boardData->hwName, 4) )
am29lvxxx_smb.c:373:			devHdl->flashDev.manId = boardData->manId;
am29lvxxx_smb.c:374:			devHdl->flashDev.devId = boardData->devId;
am29lvxxx_smb.c:375:			G_DoBitReverse = boardData->doBitReverse;
am29lvxxx_smb.c:382:	if( !boardData->devId )
am29lvxxx_smb.c:393:		devHdl->flashDev.manId = 0xff;
am29lvxxx_smb.c:394:		devHdl->flashDev.devId = 0xff;
am29lvxxx_smb.c:397:	if( devHdl->dbgLevel )
am29lvxxx_smb.c:399:				(unsigned int)devHdl->flashDev.manId,
am29lvxxx_smb.c:400:				(int)devHdl->flashDev.devId);
am29lvxxx_smb.c:407: * ---------------------------------------------------------------------------
am29lvxxx_smb.c:410: *  Globals....: -
am29lvxxx_smb.c:416:	/*--- check if device supported ---*/
am29lvxxx_smb.c:417:	if( devHdl->flashDev.manId == MANUFACT_AMD ||
am29lvxxx_smb.c:418:		devHdl->flashDev.manId == MANUFACT_ST )
am29lvxxx_smb.c:425:				  devHdl->flashDev.devId,
am29lvxxx_smb.c:426:			 	  devHdl->flashDev.manId,
am29lvxxx_smb.c:427:			 	  devHdl->flash_acc_size));
am29lvxxx_smb.c:429:		while( d->devId ){
am29lvxxx_smb.c:430:			if( ((devHdl->flash_acc_size &&
am29lvxxx_smb.c:431:				  devHdl->flashDev.devId == d->devId) ||
am29lvxxx_smb.c:432:			 	 ((devHdl->flashDev.devId & 0xff) == (d->devId & 0xff))) &&
am29lvxxx_smb.c:433:			 	(devHdl->flashDev.manId == d->manId) )
am29lvxxx_smb.c:435:				if(devHdl->dbgLevel)
am29lvxxx_smb.c:437:						 "Found FLASH device %s\n", d->name );
am29lvxxx_smb.c:439:				devHdl->flashDev.sectSize = d->sectSize;
am29lvxxx_smb.c:440:				devHdl->flashDev.nSectors = d->nSectors;
am29lvxxx_smb.c:441:				devHdl->flashDev.bootSect = d->bootSect;
am29lvxxx_smb.c:443:					devHdl->flashDev.sectAddr[i] = d->sectAddr[i];
am29lvxxx_smb.c:444:				devHdl->flashDev.devHdl   = devHdl;
am29lvxxx_smb.c:445:				devHdl->flashDev.isInit  = 0;
am29lvxxx_smb.c:449:					 "Missed match at FLASH device %s\n", d->name ));
am29lvxxx_smb.c:460: *---------------------------------------------------------------------------
am29lvxxx_smb.c:469:	SMB_HANDLE *smbHdl = (SMB_HANDLE*)fDev->devHdl->smbLocHdl.smbHdl;
am29lvxxx_smb.c:474:	/* read the status of cmd-register */
am29lvxxx_smb.c:475:	if( (error = smbHdl->ReadByte( smbHdl, 0,
am29lvxxx_smb.c:485:	if( (error = smbHdl->WriteByte(  smbHdl, 0,
am29lvxxx_smb.c:494:	/* read the status of cmd-register */
am29lvxxx_smb.c:495:	if( (error = smbHdl->ReadByte( smbHdl, 0,
am29lvxxx_smb.c:504:	/* test the bit flash-rdy, and read again if not set */
am29lvxxx_smb.c:506:		if( (error = smbHdl->ReadByte( smbHdl, 0,
am29lvxxx_smb.c:524: *---------------------------------------------------------------------------
am29lvxxx_smb.c:544: *---------------------------------------------------------------------------
am29lvxxx_smb.c:564:	SMB_HANDLE *smbHdl = (SMB_HANDLE*)fDev->devHdl->smbLocHdl.smbHdl;
am29lvxxx_smb.c:571:    if( ( offs >= fDev->sectAddr[fDev->nSectors]*2) ||
am29lvxxx_smb.c:572:        ((offs + len) > fDev->sectAddr[fDev->nSectors]*2))
am29lvxxx_smb.c:579:	/* read the status of cmd-register */
am29lvxxx_smb.c:580:	if( (error = smbHdl->ReadByte( smbHdl, 0,
am29lvxxx_smb.c:591:	if( (error = smbHdl->WriteByte(  smbHdl, 0,
am29lvxxx_smb.c:603:		if( (error = smbHdl->ReadWordData( smbHdl, 0,
am29lvxxx_smb.c:609:					functionName, (int)(offs/2 - i), (int)error);
am29lvxxx_smb.c:612:		i--;
am29lvxxx_smb.c:626:		if( (error = smbHdl->WriteWordData(  smbHdl, 0,
am29lvxxx_smb.c:633:					(int)(offs+((len/2+len%2)-nWrite)* 2),	(int)error);
am29lvxxx_smb.c:639:				 (int)(offs + ((len/2+len%2)-nWrite)*2), (int)*bufp16 ));
am29lvxxx_smb.c:646:		/* read the status of cmd-register */
am29lvxxx_smb.c:647:		if( (error = smbHdl->ReadByte( smbHdl, 0,
am29lvxxx_smb.c:656:		/* test the bit flash-rdy, and read again if not set */
am29lvxxx_smb.c:658:			if( (error = smbHdl->ReadByte( smbHdl, 0,
am29lvxxx_smb.c:670:		nWrite--;
am29lvxxx_smb.c:682: *---------------------------------------------------------------------------
am29lvxxx_smb.c:702:	SMB_HANDLE *smbHdl = (SMB_HANDLE*)fDev->devHdl->smbLocHdl.smbHdl;
am29lvxxx_smb.c:708:	/* read the status of cmd-register */
am29lvxxx_smb.c:709:	if( (error = smbHdl->ReadByte( smbHdl, 0,
am29lvxxx_smb.c:720:	if( (error = smbHdl->WriteByte(  smbHdl, 0,
am29lvxxx_smb.c:732:		if( (error = smbHdl->ReadWordData( smbHdl, 0,
am29lvxxx_smb.c:738:					functionName, (int)(offs/2 - i), (int)error);
am29lvxxx_smb.c:741:		i--;
am29lvxxx_smb.c:747:		if( (error = smbHdl->ReadWordData( smbHdl, 0,
am29lvxxx_smb.c:753:					functionName, (int)(offs/2 - i), (int)error);
am29lvxxx_smb.c:765:				functionName, (int)(len / 2 + len%2 - nAccess),
am29lvxxx_smb.c:766:				(int)(offs + (len / 2 + len%2 - nAccess)*2), (u_int16)*bufp16));
am29lvxxx_smb.c:769:		nAccess--;
am29lvxxx_smb.c:777: *---------------------------------------------------------------------------
am29lvxxx_smb.c:782:	SMB_HANDLE *smbHdl = (SMB_HANDLE*)fDev->devHdl->smbLocHdl.smbHdl;
am29lvxxx_smb.c:787:	/* read the status of cmd-register */
am29lvxxx_smb.c:788:	if( (error = smbHdl->ReadByte( smbHdl, 0,
am29lvxxx_smb.c:798:	if( (error = smbHdl->WriteByte(  smbHdl, 0,
am29lvxxx_smb.c:812: *---------------------------------------------------------------------------
am29lvxxx_smb.c:843: *---------------------------------------------------------------------------
am29lvxxx_smb.c:848: *  \return	sector number or error (-1) if not found
am29lvxxx_smb.c:854:	addr &= (fDev->sectAddr[fDev->nSectors]*2 - 1);
am29lvxxx_smb.c:856:	for( sect=0; sect < fDev->nSectors; sect++ ){
am29lvxxx_smb.c:857:		if( addr >= fDev->sectAddr[sect]*2 &&
am29lvxxx_smb.c:858:			addr < fDev->sectAddr[sect+1]*2){
am29lvxxx_smb.c:859:			*phySizeP = (fDev->sectAddr[sect+1] - fDev->sectAddr[sect])*2;
am29lvxxx_smb.c:863:	return -1;
README.md:4:Prerequisites: install pciutils and pciutils-dev (or pciutils-devel)  (use apt, yum, zypper,…) Get A25 project         
README.md:6:    $ git clone https://github.com/MEN-Mikro-Elektronik/A25_MDIS_project.git
README.md:10:    $ git clone https://github.com/MEN-Mikro-Elektronik/MDISforLinux.git  
README.md:12:    $ git submodule update --init --recursive 
README.md:27:    ---
README.md:37:    ---
README.md:51:    <          # define TASK_LOCK_SIGNALS(t,flags)         spin_lock_irqsave(&(t)->sighand->siglock, flags); 
README.md:52:    <          # define TASK_UNLOCK_SIGNALS(t,flags)   spin_unlock_irqrestore(&(t)->sighand->siglock, flags); 
README.md:55:    <          # define TASK_LOCK_SIGNALS(t,flags)         spin_lock_irqsave(&(t)->sigmask_lock, flags); 
README.md:56:    <          # define TASK_UNLOCK_SIGNALS(t,flags)   spin_unlock_irqrestore(&(t)->sigmask_lock, flags); 
README.md:59:    ---
README.md:61:    >          # define TASK_LOCK_SIGNALS(t,flags)         spin_lock_irqsave(&(t)->sighand->siglock, flags); 
README.md:62:    >          # define TASK_UNLOCK_SIGNALS(t,flags)   spin_unlock_irqrestore(&(t)->sighand->siglock, flags); 
README.md:68:    ---
README.md:81:    ---
Binary file .fpga_load.c.swp matches
_st_stub.c:1:/*********************  P r o g r a m  -  M o d u l e ***********************/
_st_stub.c:12: *     Required: -
_st_stub.c:15: /*---------------------------[ Public Functions ]----------------------------
_st_stub.c:18: *---------------------------------------------------------------------------
.gitignore:1:# +---------------------------------------------------------------------------+
.gitignore:3:# +---------------------------------------------------------------------------+
.gitignore:21:# +---------------------------------------------------------------------------+
.gitignore:23:# +---------------------------------------------------------------------------+
_amd_smb_sw_stub.c:1:/*********************  P r o g r a m  -  M o d u l e ***********************/
_amd_smb_sw_stub.c:12: *     Required: -
_amd_smb_sw_stub.c:15: /*---------------------------[ Public Functions ]----------------------------
_amd_smb_sw_stub.c:18: *---------------------------------------------------------------------------
fpga_load_doc.c:1:/*********************  P r o g r a m  -  M o d u l e ***********************/
fpga_load_doc.c:11: *     Required: -
fpga_load_doc.c:13: *     \switches -
fpga_load_doc.c:15: *---------------------------------------------------------------------------
fpga_load_doc.c:46:    The FPGA_LOAD tool adapts at runtime to 8bit or 16bit FPGA-Flash interface
fpga_load_doc.c:47:    and swapped or non-swapped versions.
fpga_load_doc.c:96:	fpga_load -h
fpga_load_doc.c:102:	  - identify the desired PCI device:
fpga_load_doc.c:104:	    > fpga_load -s
fpga_load_doc.c:105:	    > fpga_load <ven ID> <dev ID> <subVen ID> -s
fpga_load_doc.c:107:	  - check that you access the correct device, read the header from FLASH
fpga_load_doc.c:109:	    > fpga_load <ven ID> <dev ID> <subVen ID> <idx> -r <offs in flash> <len>
fpga_load_doc.c:111:	  - show the Chameleon Table within the FPGA
fpga_load_doc.c:113:	    > fpga_load <ven ID> <dev ID> <subVen ID> <idx> -t
fpga_load_doc.c:115:	  - use the 16Z126_SPI_FLASH interface, read the header from FLASH
fpga_load_doc.c:117:	    > fpga_load <ven ID> <dev ID> <subVen ID> <idx> -z -r <offs in flash> <len>
fpga_load_doc.c:119:	  - load/update the FPGA
fpga_load_doc.c:121:	    > fpga_load <ven ID> <dev ID> <subVen ID> <idx> -u <FPGA update file> <offset in flash>
fpga_load_doc.c:125:	  > fpga_load -s
fpga_load_doc.c:126:	  > fpga_load 0x1172 0x4d45 0x7 0 -r 0x0 0x100
fpga_load_doc.c:127:	  > fpga_load 0x1172 0x4d45 0x7 0 -t
fpga_load_doc.c:128:	  > fpga_load 0x1172 0x4d45 0x7 0 -z -r 0x0 0x100
fpga_load_doc.c:129:	  > fpga_load 0x1172 0x4d45 0x7 0 -u P018-00IC001D4.rbf 0x0
fpga_load_doc.c:138:	  - check that you access the correct address, read the header from FLASH
fpga_load_doc.c:140:	    > fpga_load -a <reg offs in VME window> -r <offs in flash> <len>
fpga_load_doc.c:142:	  - check that you access the correct address with the SPI Flash, read the header from FLASH
fpga_load_doc.c:144:	    > fpga_load -a <reg offs in VME window> -z -r <offs in flash> <len>
fpga_load_doc.c:146:	  - load/update the FPGA (verify header)
fpga_load_doc.c:148:	    > fpga_load -a <reg offs in VME window> -u <FPGA update file> <offset in flash>
fpga_load_doc.c:150:	  - load/update the FPGA (ignore header)
fpga_load_doc.c:152:	    > fpga_load -a <reg offs in VME window> -f -w <FPGA update file> <offset in flash>
fpga_load_doc.c:156:	  > fpga_load -a 0xe003a0 -r 0x0 0x100
fpga_load_doc.c:157:	  > fpga_load -a 0xe003a0 -z -r 0x0 0x100
fpga_load_doc.c:158:	  > fpga_load -a 0xe003a0 -u A203N00IC041A1.rbf 0x0
fpga_load_doc.c:159:	  > fpga_load -a 0xe003a0 -f -w A203N00IC041A1.rbf 0x0
fpga_load_doc.c:169:	  - check that you access the correct address, read the header from FLASH
fpga_load_doc.c:171:	    > fpga_load -a <reg offs in VME window> -p <smb controller> -r <offs in flash> <len>
fpga_load_doc.c:173:	  - load/update the FPGA (verify header)
fpga_load_doc.c:175:	    > fpga_load -a <reg offs in VME window> -p <smb controller> -u <FPGA update file> <offset in flash>
fpga_load_doc.c:177:	  - load/update the FPGA (ignore header)
fpga_load_doc.c:179:	    > fpga_load -a <reg offs in VME window> -p <smb controller> -f -w <FPGA update file> <offset in flash>
fpga_load_doc.c:181:	  - chek that you access the correct address for direct addressing for e.g. M-Modules
fpga_load_doc.c:183:	    > fpga_load -d <reg offs> -r <offs in flash> <len> [<file>]
fpga_load_doc.c:187:	  > fpga_load -a 0xfd8000 -p "menz001" -r 0x0 0x100
fpga_load_doc.c:188:	  > fpga_load -a 0xfd8000 -p "menz001" -u A404-00IC090A1.rbf 0x0
fpga_load_doc.c:189:	  > fpga_load -a 0xfd8000 -p "menz001" -f -w A404-00IC090A1.rbf 0x0
fpga_load_doc.c:190:	  > fpga_load -d 0x88e000f0 -r 0x0 0x800000 file.bin
fpga_load_doc.c:195:	  - check that you access the correct SMB device, read the header from FLASH
fpga_load_doc.c:197:	    > fpga_load -p <smb controller number> -r <offs in flash> <len>
fpga_load_doc.c:199:	  - load/update the FPGA (verify header)
fpga_load_doc.c:201:	    > fpga_load -p <smb controller number> -u <FPGA update file> <offset in flash>
fpga_load_doc.c:203:	  - load/update the FPGA (ignore header)
fpga_load_doc.c:205:	    > fpga_load -p <smb controller number> -f -w <FPGA update file> <offset in flash>
fpga_load_doc.c:209:	  > fpga_load -p 0 -r 0x0 0x100
fpga_load_doc.c:210:	  > fpga_load -p 0 -u A404-00IC090A1.rbf 0x0
fpga_load_doc.c:211:	  > fpga_load -p 0 -f -w A404-00IC090A1.rbf 0x0
fpga_load_doc.c:218:	  - check that you access the correct SMBus/device, read the header/start of
fpga_load_doc.c:219:	    FPGA file from FLASH. The FPGA data in A500-R02 boards Flash memory starts
fpga_load_doc.c:228:	    > fpga_load -p <smb controller number> -r 0x00 0x300
fpga_load_doc.c:230:	  - set bus switches
fpga_load_doc.c:232:	    > fpga_load -p <smb controller number> -x <1/2/3>
fpga_load_doc.c:236:	  > fpga_load -p 1 -x 1
fpga_load.c~:13: *     Required: uti.l (under OS-9), libuti.a (under Linux)
fpga_load.c~:18: *-----------------------------------------------------------------------------
fpga_load.c~:19: * (c) Copyright 2004-2005 by MEN Mikro Elektronik GmbH, Nuremberg, Germany
fpga_load.c~:46:/*-----------------------------------------+
fpga_load.c~:48: +-----------------------------------------*/
fpga_load.c~:88:/*-----------------------------------------+
fpga_load.c~:90: +-----------------------------------------*/
fpga_load.c~:91:#define FPGA_P_HELP "           type fpga_load -h for help\n"
fpga_load.c~:109:/*-----------------------------------------+
fpga_load.c~:111: +-----------------------------------------*/
fpga_load.c~:112:/*-----------------------------------------+
fpga_load.c~:114: +-----------------------------------------*/
fpga_load.c~:217:			" options -b/-o (PCI), -a (VME), -d (ISA/LPC).\n"
fpga_load.c~:218:			" Without option -b/-o (PCI) or with option -k (ISA/LPC), the\n"
fpga_load.c~:223:			" ----- PCIbus -----\n"
fpga_load.c~:224:			" <vendor-id>         PCI vendor ID (e.g. 0x1172)\n"
fpga_load.c~:225:			" <device-id>         PCI device ID (e.g. 0x4D45 for chameleon_2 dev)\n"
fpga_load.c~:226:			" <sub-vendor-id>     PCI subsystem vendor ID (e.g. 0x0007 for 15P018)\n"
fpga_load.c~:227:			" <instance-nbr>      instance number of PCI Chameleon FPGA (see -s)\n"
fpga_load.c~:228:			" [-b <bar>           PCI BAR number 0..5\n"
fpga_load.c~:229:			"  -o <offset>]       offset from specified BAR to flash interface\n"
fpga_load.c~:230:			" -s                  only show all PCI device instances that match to\n"
fpga_load.c~:231:			"                      <vendor-id>, <device-id>, <sub-vendor-id>\n"
fpga_load.c~:233:			" -i <offset>         CPU to PCI io-mapped offset                           [0x0]\n"
fpga_load.c~:234:			" -m <offset>         CPU to PCI memory-mapped offset                       [0x0]\n"
fpga_load.c~:235:			" -g=<PCI domain>     #of PCI ctrl. to use (PCI domain). currently only A21 [0x0]\n"
fpga_load.c~:239:			"----- VMEbus -----\n"
fpga_load.c~:240:			" -a <VME-addr>       directly specify VME address of flash interface\n"
fpga_load.c~:242:			"----- ISA/LPC -----\n"
fpga_load.c~:243:			" -d <addr>           directly specify address of flash interface,\n"
fpga_load.c~:244:			"		              !!!ATTENTION: No flash type validation, please specify -z or -j.\n"
fpga_load.c~:246:			" -k <tbl-addr>       use Chameleon table at specified address,\n"
fpga_load.c~:250:			" -z                  use only SPI Flashes with 16Z126 flash Interface\n"
fpga_load.c~:251:			" -j		      use only Parallel Flashes\n"
fpga_load.c~:253:			" -p <SMB-ctrlr>      use SMB flash interface instead of 16Z045_FLASH,\n"
fpga_load.c~:254:			"                      list of supported SMB-ctrlr:\n"
fpga_load.c~:259:			" -u <file> <nr>      update FPGA config Nr. <0-3> in flash\n"
fpga_load.c~:263:			" -r <start> <len>    read <len> bytes from the flash at offset <start>\n"
fpga_load.c~:266:			" -l                  load new FPGA config at end                          [FALSE]\n"
fpga_load.c~:269:			" -f <force-cmd>       switch to force moden, (use one of the cmds below)\n"
fpga_load.c~:271:			"                       - no header validation will be performed\n"
fpga_load.c~:272:			"                       - all options must be passed by command line\n"
fpga_load.c~:273:			"                       - full access to flash commands is granted\n"
fpga_load.c~:274:			"                       - more than one command can be passed\n"
fpga_load.c~:276:			"   -c                  erase chip\n"
fpga_load.c~:277:			"   -e <start> <len>    erase complete blocks, starting with the block\n"
fpga_load.c~:280:			"   -w <file> <start>   write <file> to the flash, starting at offset\n"
fpga_load.c~:284:			" -x <z>              set bus switches of A500 ESM carrier\n"
fpga_load.c~:290:			"    -t                shows the chameleon table                           [no]\n"
fpga_load.c~:291:			"    -n                version information                                 [no]\n"
fpga_load.c~:292:			"    -v                verbose mode                                        [no]\n"
fpga_load.c~:293:			"    -h / -?           print this help                                     [no]\n"
fpga_load.c~:297:			"		Dump Chameleon Table: fpga_load -k 0xe000e000 -t\n"
fpga_load.c~:298:			"		Program FPGA File:    fpga_load -k 0xe000e000 -z -f -w <filename> 80000\n"
fpga_load.c~:300:			"		Dump Chameleon Table: fpga_load 1a88 4d45 b3 0 -t\n"
fpga_load.c~:301:			"		Program FPGA File:	  fpga_load 1a88 4d45 b3 0 -z -f -w <filename.rbf> 0\n"
fpga_load.c~:306:		   "(c) 2004-2013 MEN Mikro Elektronik GmbH. File revision:\n%s",RCSid);
fpga_load.c~:370:	G_pHga = &osHdl->pciGenDevice;
fpga_load.c~:384:	h->flashDev.devHdl = h;
fpga_load.c~:411:	h->dbgLevel	  = (UTL_TSTOPT("v") ? 1 : 0);
fpga_load.c~:413:	if( h->dbgLevel )
fpga_load.c~:424:		h->smbLocHdl.smbCtlName[0] = 0;
fpga_load.c~:427:			if( !strcmp( "-p", *largv ) ) {
fpga_load.c~:429:					(!sscanf(largv[1],"%u",(unsigned int*)&h->smbLocHdl.smbCtlNum) &&
fpga_load.c~:430:					 !sscanf(largv[1],"%s",h->smbLocHdl.smbCtlName)) )
fpga_load.c~:432:					printf("*** ERROR: option -p requires type/number of SMB "
fpga_load.c~:439:			largc--;
fpga_load.c~:464:		h->interfacespi = 1;
fpga_load.c~:467:		h->interfacespi = 0;
fpga_load.c~:469:		printf("*** ERROR: please specify the flash type (-j or -z)\n");
fpga_load.c~:476:	if( !flashInterf || *h->smbLocHdl.smbCtlName ) {
fpga_load.c~:490:				if ( !strcmp( "-d", *largv )) {
fpga_load.c~:494:						printf("*** ERROR: option -d requires address as hex value\n"
fpga_load.c~:501:    			largc--;
fpga_load.c~:505:			h->physAddr = (void *)(BusAddr & ~0x1);
fpga_load.c~:506:			h->busType  = OSS_BUSTYPE_NONE;
fpga_load.c~:512:				h->mapType = OSS_ADDRSPACE_IO;
fpga_load.c~:515:				h->mapType  = OSS_ADDRSPACE_MEM;
fpga_load.c~:552:			if( !strcmp( "-u", *largv ) ) {
fpga_load.c~:556:			largc--;
fpga_load.c~:569:			if( !strcmp( "-r", *largv ) )
fpga_load.c~:576:			largc--;
fpga_load.c~:588:			if( !strcmp( "-x", *largv ) ) {
fpga_load.c~:595:			largc--;
fpga_load.c~:607:			if( !strcmp( "-f", *argv ) ) {
fpga_load.c~:610:			argc--;
fpga_load.c~:616:		if( !strcmp( "-l", *argv ) ) {
fpga_load.c~:618:			argc--;
fpga_load.c~:623:		if( !strcmp( "-c", *argv ) ) {
fpga_load.c~:626:				argc -= rc;
fpga_load.c~:635:		if( !strcmp( "-e", *argv ) ) {
fpga_load.c~:638:				argc -= rc;
fpga_load.c~:647:		if( !strcmp( "-r", *argv ) ) {
fpga_load.c~:650:				argc -= rc;
fpga_load.c~:659:		if( !strcmp( "-w", *argv ) ) {
fpga_load.c~:662:				argc -= rc;
fpga_load.c~:672:		if( !strcmp( "-i", *argv ) ||
fpga_load.c~:673:			!strcmp( "-m", *argv ) ) { /* ignore -i and -m option here */
fpga_load.c~:674:			argc -= 2;
fpga_load.c~:680:		if( !strcmp( "-v", *argv ) ) { /* ignore -v option here */
fpga_load.c~:681:			argc--;
fpga_load.c~:686:		argc--; argv++;
fpga_load.c~:694:		if( h->flashDev.isInit  )
fpga_load.c~:695:			h->flash_entry.Exit(&h->flashDev);
fpga_load.c~:697:		if( h->smbLocHdl.smbHdl )
fpga_load.c~:700:		if( h->mappedAddr ) {
fpga_load.c~:711:								  (void**)&h->mappedAddr,
fpga_load.c~:712:								  h->mappedSize,
fpga_load.c~:713:								  h->mapType);
fpga_load.c~:734: *  \return	          success (0) or error (-1)
fpga_load.c~:739:		return -1;
fpga_load.c~:752: * 					or error (-error)
fpga_load.c~:759:	if( h->dbgLevel )
fpga_load.c~:762:	h->flash_entry.Reset(&h->flashDev);
fpga_load.c~:763:	error = h->flash_entry.EraseChip(&h->flashDev);
fpga_load.c~:765:	if( h->dbgLevel && !error )
fpga_load.c~:766:		printf("----> OK: Chip Erased\n\n");
fpga_load.c~:780: * 					or error (-error)
fpga_load.c~:788:	if( h->dbgLevel )
fpga_load.c~:794:		printf("\n*** ERROR: -e requires address in the sector to erase first\n"
fpga_load.c~:801:	h->flash_entry.Reset(&h->flashDev);
fpga_load.c~:806:	if((error = h->flash_entry.EraseSectors(&h->flashDev, startOffs, len)))
fpga_load.c~:811:		h->flash_entry.Reset(&h->flashDev);
fpga_load.c~:825: * 					or error (-error)
fpga_load.c~:840:	if( h->dbgLevel )
fpga_load.c~:846:		printf("\n*** ERROR: Option -r requires at least "
fpga_load.c~:851:				*argv[3] != '-' &&
fpga_load.c~:865:	h->flash_entry.ReadBlock(&h->flashDev, startOffset, len, buf);
fpga_load.c~:870:		else if( h->dbgLevel )
fpga_load.c~:889:		h->flash_entry.Reset(&h->flashDev);
fpga_load.c~:907: * 					or error (-error)
fpga_load.c~:928:	if( h->dbgLevel )
fpga_load.c~:932:		printf("\n*** ERROR: Option -w requires at least the file to be loaded\n");
fpga_load.c~:949:		printf("\n*** ERROR: Option -w requires offset\n");
fpga_load.c~:955:	if( h->dbgLevel )
fpga_load.c~:958:	if( (error = h->flash_entry.EraseSectors( &h->flashDev, startOffset,
fpga_load.c~:961:	else if( h->dbgLevel )
fpga_load.c~:962:		printf("  ----> OK\n\n");
fpga_load.c~:964:	h->flash_entry.Reset(&h->flashDev);
fpga_load.c~:965:	if( h->dbgLevel )
fpga_load.c~:968:    if( (error = h->flash_entry.WriteBlock( &h->flashDev,
fpga_load.c~:977:	h->flash_entry.Reset(&h->flashDev);
fpga_load.c~:986:	h->flash_entry.Reset(&h->flashDev);
fpga_load.c~:994:		h->flash_entry.Reset(&h->flashDev);
fpga_load.c~:1008: *	\return -
fpga_load.c~:1013:	if( h->mapType )
fpga_load.c~:1015:		Z100_Mwrite_Io_D32( h->mappedAddr,
fpga_load.c~:1022:		Z100_MWRITE_D32( h->mappedAddr,
fpga_load.c~:1036: * 					or error (-error)
fpga_load.c~:1053:	if( h->dbgLevel )
fpga_load.c~:1057:		printf("\n*** ERROR: option -u requires filename (see \"fpga_load -h\")\n");
fpga_load.c~:1080:	if( h->interfacespi ){
fpga_load.c~:1094:		Get_FpgaHeader( &h->flashDev, 0x00, &header );
fpga_load.c~:1110:	if( Z100_SWAP_BE32(headerP1->magic) != FPGA_LONGHEADER_MAGIC ) {
fpga_load.c~:1115:	if( strcmp(header.boardType, headerP1->boardType) ) {
fpga_load.c~:1127:		for( xor=0,i=0; i<(fileSize-FPGA_SIZE_HEADER_LONG)/4; i++ )
fpga_load.c~:1132:		if( headerP1->chksum != xor ) {
fpga_load.c~:1143:	if( h->dbgLevel )
fpga_load.c~:1147:	if( (error = h->flash_entry.EraseSectors( &h->flashDev, startOffset,
fpga_load.c~:1149:		return( -error );
fpga_load.c~:1150:	else if( h->dbgLevel )
fpga_load.c~:1151:		printf("  ----> OK\n\n");
fpga_load.c~:1154:	h->flash_entry.Reset(&h->flashDev);
fpga_load.c~:1156:	if( h->dbgLevel )
fpga_load.c~:1158:	h->flash_entry.WriteBlock(&h->flashDev, startOffset, fileSize, fBuf );
fpga_load.c~:1167:	h->flash_entry.Reset(&h->flashDev);
fpga_load.c~:1175:		h->flash_entry.Exit(&h->flashDev);
fpga_load.c~:1199: * 					or error (-error)
fpga_load.c~:1218:	if( h->dbgLevel )
fpga_load.c~:1224:		printf("\n*** ERROR: option -x requires bus switch [1/2/3] (see \"fpga_load -h\")\n");
fpga_load.c~:1230:		if( h->dbgLevel ) {
fpga_load.c~:1238:		if( h->dbgLevel ) {
fpga_load.c~:1246:		if( h->dbgLevel ) {
fpga_load.c~:1256:	if( (error = FindFlashSect( &h->flashDev,
fpga_load.c~:1276:	h->flash_entry.ReadBlock(&h->flashDev, sectAddr, sectSize, buf);
fpga_load.c~:1282:	if( h->dbgLevel )
fpga_load.c~:1287:	if( (error = h->flash_entry.EraseSectors( &h->flashDev, sectAddr,
fpga_load.c~:1290:	else if( h->dbgLevel )
fpga_load.c~:1291:		printf("  ----> OK\n\n");
fpga_load.c~:1294:	h->flash_entry.Reset(&h->flashDev);
fpga_load.c~:1295:	if( h->dbgLevel )
fpga_load.c~:1297:	h->flash_entry.WriteBlock(&h->flashDev, sectAddr, sectSize, buf );
fpga_load.c~:1300:	h->flash_entry.Reset(&h->flashDev);
fpga_load.c~:1309:	h->flash_entry.Reset(&h->flashDev);
fpga_load.c~:1314:		h->flash_entry.Reset(&h->flashDev);
fpga_load.c~:1329: *  \param flashInterf	\IN		0 - Z045_FLASH, 1 - PLD/SMB
fpga_load.c~:1343:	if(h->dbgLevel)
fpga_load.c~:1351:		if( h->mapType == OSS_ADDRSPACE_IO ){
fpga_load.c~:1352:			h->mappedAddr = (u_int8*)h->physAddr;
fpga_load.c~:1359:								 h->physAddr,
fpga_load.c~:1361:								 h->mapType,
fpga_load.c~:1362:								 h->busType,
fpga_load.c~:1363:								 h->pciDev.bus,
fpga_load.c~:1364:								 (void**)&h->mappedAddr)) )
fpga_load.c~:1367:						(unsigned int)h->physAddr, (int)error);
fpga_load.c~:1375:		h->mappedSize = MAP_REG_SIZE;
fpga_load.c~:1376:		h->smbLocHdl.smbHdl = NULL;
fpga_load.c~:1381:		if( !h->smbLocHdl.smbHdl ) {
fpga_load.c~:1385:		h->flash_acc_size = Z100_FLASH_ACCESS_16BIT;
fpga_load.c~:1392:	     if(h->interfacespi){
fpga_load.c~:1396:                if( ((*Flash_try)(h, &Flash_init, h->dbgLevel)) == 0){
fpga_load.c~:1404:        		if( ((*Flash_try)(h, &Flash_init, h->dbgLevel)) == 0){
fpga_load.c~:1427: *  \return			file size or error (-1)
fpga_load.c~:1442:	/*----------------------------------+
fpga_load.c~:1444:	+----------------------------------*/
fpga_load.c~:1448:		return( -1 );
fpga_load.c~:1459:		error = -1;
fpga_load.c~:1465:		error = -1;
fpga_load.c~:1475:	if ( error == -1 )
fpga_load.c~:1488: *  \return			success (0) or error (-1)
fpga_load.c~:1495:	/*----------------------------------+
fpga_load.c~:1497:	+----------------------------------*/
fpga_load.c~:1501:		return(-1);
fpga_load.c~:1506:		return(-1);
fpga_load.c~:1525: * \return 0 on success or -1 if failed
fpga_load.c~:1554:		/*------------------------------+
fpga_load.c~:1556:		+------------------------------*/
fpga_load.c~:1579:		/* try non-swapped and swapped */
fpga_load.c~:1598:		/*------------------------------+
fpga_load.c~:1600:		+------------------------------*/
fpga_load.c~:1610:						 OSS_MERGE_BUS_DOMAIN(pciDev->bus, pciDomain),		/* pciBus */
fpga_load.c~:1611:						 pciDev->dev,		/* pciDev */
fpga_load.c~:1612:						 pciDev->fun,		/* pciFunc*/
fpga_load.c~:1618:						 OSS_MERGE_BUS_DOMAIN(pciDev->bus, pciDomain),	/* pciBus */
fpga_load.c~:1619:						 pciDev->dev,	/* pciDev */
fpga_load.c~:1620:				 		 pciDev->fun,	/* pciFunc*/
fpga_load.c~:1627:						 OSS_MERGE_BUS_DOMAIN(pciDev->bus, pciDomain),	/* pciBus */
fpga_load.c~:1628:						 pciDev->dev,	/* pciDev */
fpga_load.c~:1629:						 pciDev->fun,	/* pciFunc*/
fpga_load.c~:1635:				OSS_MERGE_BUS_DOMAIN(pciDev->bus, pciDomain),	/* pciBus */
fpga_load.c~:1636:				pciDev->dev,	/* pciDev */
fpga_load.c~:1637:				pciDev->fun,	/* pciFunc*/
fpga_load.c~:1647:					(int)pciDev->bus, (int)pciDev->dev, (int)pciDev->fun, (unsigned int)ret);
fpga_load.c~:1652:	/*------------------------------+
fpga_load.c~:1653:	|  CHAM - Info                  |
fpga_load.c~:1654:	+------------------------------*/
fpga_load.c~:1655:	if( chaFktTbl->Info( chaHdl, chamInfo ) != 0 )	{
fpga_load.c~:1665:					pciDev->bus, pciDev->dev, pciDev->fun);
fpga_load.c~:1679:				pciDev->bus, pciDev->dev, pciDev->fun);
fpga_load.c~:1684:					(int)i, (int)chamInfo->ba[i].addr,
fpga_load.c~:1685:					(int)chamInfo->ba[i].size,
fpga_load.c~:1686:					chamInfo->ba[i].type == 0 ? "MEM" :
fpga_load.c~:1687:					chamInfo->ba[i].type == 1 ? "IO" : "unused");
fpga_load.c~:1690:	/*------------------------------+
fpga_load.c~:1691:	|  CHAM - TableIdent            |
fpga_load.c~:1692:	+------------------------------*/
fpga_load.c~:1694:		if( (ret = chaFktTbl->TableIdent( chaHdl, i, &chamTable )) ==
fpga_load.c~:1708:						pciDev->bus, pciDev->dev, pciDev->fun);
fpga_load.c~:1728:			printf("gateware-revision: %d.%d\n", chamTable.revision, chamTable.minRevision);
fpga_load.c~:1729:			printf("fpga-model: %c\n", chamTable.model);
fpga_load.c~:1730:			printf("fpga-file: %s\n", tblfile);
fpga_load.c~:1731:			printf("magic-word: 0x%04x\n", chamTable.magicWord);
fpga_load.c~:1736:	/*------------------------------+
fpga_load.c~:1737:	|  CHAM - UnitIdent             |
fpga_load.c~:1738:	+------------------------------*/
fpga_load.c~:1742:				"--- ------ ------------------------ --- ---- --- --- --- --- ---------- ----------\n");
fpga_load.c~:1747:		if( (ret = chaFktTbl->UnitIdent( chaHdl, i, chamUnit )) ==
fpga_load.c~:1761:						pciDev->bus, pciDev->dev, pciDev->fun);
fpga_load.c~:1767:			printf("%3d 0x%04x %-24s %3d %4d %3d %3d %3d %3d 0x%08lx %p\n",
fpga_load.c~:1768:				   (int)i, chamUnit->devId,CHAM_DevIdToName(chamUnit->devId),chamUnit->group,
fpga_load.c~:1769:				   chamUnit->instance, chamUnit->variant, chamUnit->revision,
fpga_load.c~:1770:				   (chamUnit->interrupt /*- SYS_NUM_CHAM_INTO*/), chamUnit->bar,
fpga_load.c~:1771:				   chamUnit->offset, chamUnit->addr);
fpga_load.c~:1775:		if( ((chamInfo->chaRev <  2) && (chamUnit->devId == mod_id))    ||
fpga_load.c~:1776:			((chamInfo->chaRev >= 2) && (chamUnit->devId == mod_id) &&
fpga_load.c~:1777:			 (chamUnit->group == mod_group)) )
fpga_load.c~:1786:		if ( chamUnit->devId == CHAMELEON_16Z126_SERFLASH )
fpga_load.c~:1791:			        pRegs = (char *)mmap( NULL, pgsz, PROT_READ | PROT_WRITE, MAP_SHARED, fd, (long)(chamUnit->addr) & ~(pgsz-1));
fpga_load.c~:1792:			        if (pRegs == (void *)-1 ) {
fpga_load.c~:1796:			        	z126Status = ((u_int32*)pRegs)[ (chamUnit->offset + SFII_BSR) >> 2 ];
fpga_load.c~:1805:	/* from 16Z126-01_IcArchSpec.doc table 31:
fpga_load.c~:1813:			printf("image-type: ");
fpga_load.c~:1816:					printf ("fallback no-config-error\n" );
fpga_load.c~:1822:					printf ("fallback config-error\n" );
fpga_load.c~:1851:	if ( !(flags & (CF_ALL_TABLES|CF_VERSION)) && ( chamUnit->devId != mod_id ) ){
fpga_load.c~:1856:		chaFktTbl->UnitIdent( chaHdl, chaUnitNbr, chamUnit );
fpga_load.c~:1859:	chaFktTbl->Term( &chaHdl );
fpga_load.c~:1868:		chaFktTbl->Term( &chaHdl );
fpga_load.c~:1877: *---------------------------------------------------------------------------
fpga_load.c~:1883: *  \return	sector number or error (-1) if not found
fpga_load.c~:1893:	for( sect=0; sect < fDev->nSectors; sect++ ){
fpga_load.c~:1894:		if( addr >= fDev->sectAddr[sect]*2 &&
fpga_load.c~:1895:			addr < fDev->sectAddr[sect+1]*2){
fpga_load.c~:1896:			*sectAddr = fDev->sectAddr[sect]*2;
fpga_load.c~:1897:			*sectSize = (fDev->sectAddr[sect+1] - fDev->sectAddr[sect])*2;
fpga_load.c~:1901:	return -1;
fpga_load.c~:1918:	fDev->devHdl->flash_entry.ReadBlock( fDev,
fpga_load.c~:1924:	if( fDev->devHdl->dbgLevel )
fpga_load.c~:1930:				(unsigned int)Z100_SWAP_BE32(header->magic),
fpga_load.c~:1931:				header->boardType,
fpga_load.c~:1932:				(unsigned int)Z100_SWAP_BE32(header->offset[0]),
fpga_load.c~:1933:				(unsigned int)Z100_SWAP_BE32(header->offset[1]),
fpga_load.c~:1934:				(unsigned int)Z100_SWAP_BE32(header->offset[2]),
fpga_load.c~:1935:				(unsigned int)Z100_SWAP_BE32(header->offset[3]) );
fpga_load.c~:1963:	h->flash_entry.Reset(&h->flashDev);
fpga_load.c~:1966:	if( h->dbgLevel )
fpga_load.c~:1978:	h->flash_entry.ReadBlock(&h->flashDev, offset, len, verBuf);
fpga_load.c~:2023:					(int)n, (int)pciDomain, (int)pciDevs[n]->bus, (int)pciDevs[n]->dev, (int)pciDevs[n]->fun,
fpga_load.c~:2024:					(unsigned int)pciDevs[n]->venId,
fpga_load.c~:2025:					(unsigned int)pciDevs[n]->devId,
fpga_load.c~:2026:					(unsigned int)pciDevs[n]->subSysVenId);
fpga_load.c~:2035:					(int)n, pciDevs[n]->bus, pciDevs[n]->dev, pciDevs[n]->fun,
fpga_load.c~:2036:					(unsigned int)pciDevs[n]->bar[0],
fpga_load.c~:2037:					(unsigned int)pciDevs[n]->bar[1],
fpga_load.c~:2038:					(unsigned int)pciDevs[n]->bar[2],
fpga_load.c~:2039:					(unsigned int)pciDevs[n]->bar[3],
fpga_load.c~:2040:					(unsigned int)pciDevs[n]->bar[4],
fpga_load.c~:2041:					(unsigned int)pciDevs[n]->bar[5]);
fpga_load.c~:2055: *  \return success (0) or error (-1)
fpga_load.c~:2065:	u_int32 vendorId=dev->venId,
fpga_load.c~:2066:			deviceId=dev->devId,
fpga_load.c~:2067:			subSysVenId=dev->subSysVenId,
fpga_load.c~:2091:				/* if PCI bus is not implemented, 0 is returned instead of -1 */
fpga_load.c~:2107:					pCurdev->bus = (u_int8)bus;
fpga_load.c~:2108:					pCurdev->dev = (u_int8)slot;
fpga_load.c~:2109:					pCurdev->fun = (u_int8)function;
fpga_load.c~:2111:					pCurdev->venId = val1;
fpga_load.c~:2116:									  (int32 *)&pCurdev->devId);
fpga_load.c~:2120:									  (int32 *)&pCurdev->subSysVenId);
fpga_load.c~:2126:					pCurdev->origComReg = (u_int16)(Z100_SWAP_BE16(comReg));
fpga_load.c~:2138:									(int32 *)&pCurdev->bar[barn]);
fpga_load.c~:2139:					pCurdev->comRegChanged = 0;
fpga_load.c~:2145:						(pCurdev->venId == vendorId) &&
fpga_load.c~:2146:						(pCurdev->devId == deviceId) &&
fpga_load.c~:2147:						(pCurdev->subSysVenId == subSysVenId) )
fpga_load.c~:2151:						if( !(pCurdev->origComReg &
fpga_load.c~:2153:							!(pCurdev->origComReg &
fpga_load.c~:2156:							pCurdev->comRegChanged = 1;
fpga_load.c~:2158:                            dev->comRegChanged = 1;
fpga_load.c~:2159:                            dev->origComReg = pCurdev->origComReg;
fpga_load.c~:2164:											Z100_SWAP_BE16(pCurdev->origComReg    |
fpga_load.c~:2191:								/* not a multi-function card */
fpga_load.c~:2221:	return( -1 );
fpga_load.c~:2253:	if( h->dbgLevel )
fpga_load.c~:2257:		if( !strcmp( "-a", *argv ) ) {
fpga_load.c~:2261:				printf("*** ERROR: option -a requires VME address as hex value\n"
fpga_load.c~:2268:		argc--;
fpga_load.c~:2297:	h->physAddr = vmeLocAddr;
fpga_load.c~:2298:	h->busType  = OSS_BUSTYPE_VME;
fpga_load.c~:2299:	h->mapType  = OSS_ADDRSPACE_MEM;
fpga_load.c~:2362:										 * accesses to PCI IO-mapped devs */
fpga_load.c~:2365:	if( h->dbgLevel )
fpga_load.c~:2372:		printf("*** ERROR: option -b requires option -o as well\n"
fpga_load.c~:2381:	showChamFlags |= (h->dbgLevel     ? CF_DEBUG : 0);
fpga_load.c~:2384:	pciDev = &h->pciDev;
fpga_load.c~:2389:		    !sscanf(argv[1], "%x", (unsigned int*)&pciDev->venId) ||
fpga_load.c~:2390:		    !sscanf(argv[2], "%x", (unsigned int*)&pciDev->devId) ||
fpga_load.c~:2391:		    !sscanf(argv[3], "%x", (unsigned int*)&pciDev->subSysVenId) ||
fpga_load.c~:2395:		    !sscanf(argv[1], "%x", (unsigned int*)&pciDev->venId) ||
fpga_load.c~:2396:		    !sscanf(argv[2], "%x", (unsigned int*)&pciDev->devId) ||
fpga_load.c~:2397:		    !sscanf(argv[3], "%x", (unsigned int*)&pciDev->subSysVenId) ||
fpga_load.c~:2423:	if( showOnly && !(pciDev->venId && pciDev->devId && pciDev->subSysVenId) ) {
fpga_load.c~:2443:	if( instance > (numDevs - 1) ) {
fpga_load.c~:2452:	if( h->dbgLevel ) {
fpga_load.c~:2457:	h->busType = OSS_BUSTYPE_PCI;
fpga_load.c~:2467:			if( !strcmp( "-m", *largv ) ) {
fpga_load.c~:2471:					printf("*** ERROR: option -m requires offset as hex value\n"
fpga_load.c~:2476:				largc -= 2;
fpga_load.c~:2480:			if( !strcmp( "-i", *largv ) ) {
fpga_load.c~:2484:					printf("*** ERROR: option -i requires offset as hex value\n"
fpga_load.c~:2489:				largc -= 2;
fpga_load.c~:2493:			largc--;
fpga_load.c~:2498:			if( pciDev->bar[i] & 0x00000001 )
fpga_load.c~:2499:				/* bar is IO-mapped */
fpga_load.c~:2500:				pciDev->bar[i] += cpu_to_pci_io_offset;
fpga_load.c~:2503:				pciDev->bar[i] += cpu_to_pci_mem_offset;
fpga_load.c~:2511:		if( h->pciDev.bar[barN] & 0x1 ) {
fpga_load.c~:2513:			h->chamInfo.ba[barN].type = OSS_ADDRSPACE_IO;
fpga_load.c~:2514:			if( h->dbgLevel )
fpga_load.c~:2517:		h->chamUnit.bar = barN;
fpga_load.c~:2518:		h->chamUnit.addr = (void*)((h->pciDev.bar[barN] & ~0x0f) +
fpga_load.c~:2520:		h->physAddr = (void*)h->chamUnit.addr;
fpga_load.c~:2521:		h->mapType = h->pciDev.bar[barN] & 0x01;
fpga_load.c~:2528:        if (h->interfacespi == 1){
fpga_load.c~:2534:			if( !strcmp(h->smbLocHdl.smbCtlName, "menz001") )
fpga_load.c~:2549:		if( (error = Get_Chameleon( osHdl, &h->pciDev, NULL, modId, grpId,
fpga_load.c~:2550:			&h->chamInfo, &h->chamUnit, showChamFlags, pciDomain)) )
fpga_load.c~:2567:		if(h->chamInfo.ba[h->chamUnit.bar].type)
fpga_load.c~:2569:			h->physAddr = (void*)h->chamUnit.addr + cpu_to_pci_io_offset;
fpga_load.c~:2572:			h->physAddr = (void*)h->chamUnit.addr + cpu_to_pci_mem_offset;
fpga_load.c~:2575:		h->physAddr = (void*)h->chamUnit.addr;
fpga_load.c~:2577:		h->mapType = h->chamInfo.ba[h->chamUnit.bar].type;
fpga_load.c~:2604:	if( h->pciDev.comRegChanged == 1 ) {
fpga_load.c~:2606:				h->pciDev.bus, h->pciDev.dev, h->pciDev.fun,
fpga_load.c~:2608:				Z100_SWAP_BE16(h->pciDev.origComReg ))))
fpga_load.c~:2644:	if( h->dbgLevel )
fpga_load.c~:2649:	showChamFlags |= (h->dbgLevel     ? CF_DEBUG : 0);
fpga_load.c~:2659:    if (h->interfacespi == 1){
fpga_load.c~:2665:		if( !strcmp(h->smbLocHdl.smbCtlName, "menz001") )
fpga_load.c~:2681:		&h->chamInfo, &h->chamUnit, showChamFlags, 0)) )
fpga_load.c~:2695:	h->physAddr = (void*)h->chamUnit.addr;
fpga_load.c~:2696:	h->mapType = h->chamInfo.ba[h->chamUnit.bar].type;
fpga_load.c~:2729:	if( h->dbgLevel )
fpga_load.c~:2733:	if( !strcmp(h->smbLocHdl.smbCtlName, "menz001") )
fpga_load.c~:2736:						 h->physAddr,
fpga_load.c~:2738:						 h->mapType,
fpga_load.c~:2739:						 h->busType,
fpga_load.c~:2740:						 h->pciDev.bus,
fpga_load.c~:2741:						 (void**)&h->mappedAddr)) )
fpga_load.c~:2744:					h->physAddr, (int)error);
fpga_load.c~:2747:		h->mappedSize = MAP_REG_SIZE;
fpga_load.c~:2749:		z001_desc.baseAddr		= (void*) h->mappedAddr;
fpga_load.c~:2757:		if( (error = SMB_MENZ001_Init( &z001_desc, osHdl, &h->smbLocHdl.smbHdl )) )
fpga_load.c~:2770:							h->smbLocHdl.smbCtlNum,
fpga_load.c~:2771:							&h->smbLocHdl.smbHdl);
fpga_load.c~:2775:		h->smbLocHdl.smbHdl = NULL;
fpga_load.c~:2806:	SMB_HANDLE *smbHdl = (SMB_HANDLE*)h->smbLocHdl.smbHdl;
fpga_load.c~:2808:	if( h->dbgLevel )
fpga_load.c~:2812:	if( *h->smbLocHdl.smbCtlName && (error = smbHdl->Exit(&h->smbLocHdl.smbHdl)) )
_amd_sw_stub.c:1:/*********************  P r o g r a m  -  M o d u l e ***********************/
_amd_sw_stub.c:12: *     Required: -
_amd_sw_stub.c:15: /*---------------------------[ Public Functions ]----------------------------
_amd_sw_stub.c:18: *---------------------------------------------------------------------------
fpga_load_flash.h:1:/***********************  I n c l u d e  -  F i l e  ***********************/
fpga_load_flash.h:14: *---------------------------------------------------------------------------
fpga_load_flash.h:39:/*-----------------------------------------+
fpga_load_flash.h:41:+-----------------------------------------*/
fpga_load_flash.h:47:/*-----------------------------------------+
fpga_load_flash.h:49:+-----------------------------------------*/
fpga_load_flash.h:51:/*-----------------------------------------+
fpga_load_flash.h:53:+-----------------------------------------*/
program.local.mak:9:#---------------------------------[ History ]---------------------------------
program.local.mak:26:#   R : Do not call the right men-oss library to build statically
program.local.mak:27:#   M : change the path and the library called from men_oss to ../men-oss
program.local.mak:48:#     - SMB support by default
program.local.mak:49:#     - smb2_all_usr lib (use SMB21 lib with MAC_USER_SPACE switch set)
program.local.mak:53:#   added: stubs for swapped and non-swapped versions
program.local.mak:79:#-----------------------------------------------------------------------------
program.local.mak:125:#	MAK_LIBS +=	$(LIB_PREFIX)$(MEN_LIB_DIR)/../men-oss$(DBGSUFFIX)$(LIB_SUFFIX)
program.local.mak:127:#		MAK_LIBS +=	$(LIB_PREFIX)$(MEN_LIB_DIR)/../men-libc$(LIB_SUFFIX)
